***
## **Список вопросов**
***
### **Реакт**
#### **Простые, общие вопросы:**
1) [**Что такое реакт?**](#react-simple_1)
2) [**Как начать работать с реактом?**](#react-simple_2)
3) [**Какие особенности есть у ректа?**](#react-simple_3)
4) [**Что такое JSX?**](#react-simple_4)
5) [**Элемент и компонент, что это и как они различаются?**](#react-simple_5)
6) [**Как в реакте создаются компоненты?**](#react-simple_6)
7) [**Когда лучше использовать классовый компонент, а когда функциональный?**](#react-simple_7)
8) [**Что такое "чистые" компоненты (Pure Components)?**](#react-simple_8)
9) [**Что такое состояние (state) в реакте?**](#react-simple_9)
10) [**Что такое пропcы (props) в реакте?**](#react-simple_10)
11) [**В чем разница между состоянием и пропсами?**](#react-simple_11)
12) [**Почему не следует обновлять состояние напрямую?**](#react-simple_12)
13) [**Для чего передаётся коллбэк вторым аргументом в `setState()`?**](#react-simple_13)
14) [**В чем разница между обработкой событий в HTML и React?**](#react-simple_14)
15) [**Как в коллбеках JSX привязываются методы или обработчики событий?**](#react-simple_15)
16) [**Как передать аргумент в "коллбек" или обработчик событий?**](#react-simple_16)
17) [**Что такое синтетические события в реакте?**](#react-simple_17)
18) [**Что такое условный рендеринг?**](#react-simple_18)
19) [**Что такое пропс `key` и в чем заключаются преимущества его использования?**](#react-simple_19)
20) [**Для чего используются ссылки (рефы, refs)?**](#react-simple_20)
21) [**Как создаются рефы?**](#react-simple_21)
22) [**Что такое передача ссылки (Forward Ref)?**](#react-simple_22)
23) [**Что лучше использовать, "коллбек-рефы" или `findDOMNode()`?**](#react-simple_23)
24) [**Что такое виртуальный DOM?**](#react-simple_24)
25) [**Как работает виртуальный DOM?**](#react-simple_25)
26) [**Что такое управляемые компоненты?**](#react-simple_26)
27) [**Что такое неуправляемые компоненты?**](#react-simple_27)
28) [**В чем разница между `createElement()` и `cloneElement()`?**](#react-simple_28)
29) [**Что такое подъём состояния в реакте?**](#react-simple_29)
30) [**Назовите стадии жизненного цикла компонента**](#react-simple_30)
31) [**Назовите методы жизненного цикла в React**](#react-simple_31)
32) [**Что такое компонент высшего порядка (Higher Order Component, HOC)?**](#react-simple_32)
33) [**Как в HOC-компоненте создаются прокси для пропcов?**](#react-simple_33)
34) [**Что такое контекст (Context)?**](#react-simple_34)
35) [**Для чего используется ключевое слово `super` с аргументом `props` в конструкторе?**](#react-simple_35)
36) [**Что такое согласование?**](#react-simple_36)
37) [**Почему в React используется `className` вместо атрибута `class`?**](#react-simple_37)
38) [**Что такое фрагмент (Fragment)?**](#react-simple_38)
39) [**Почему фрагменты лучше, чем `div`?**](#react-simple_39)
40) [**Что такое компонент без состояния?**](#react-simple_40)
41) [**Что такое компонент с состоянием?**](#react-simple_41)
42) [**Как осуществить проверку пропов в React?**](#react-simple_42)
43) [**Какие преимущества предоставляет использование React?**](#react-simple_43)
44) [**Какие ограничения имеются в React?**](#react-simple_44)
45) [**Как использовать стили в React?**](#react-simple_45)
46) [**Чем отличаются события в React?**](#react-simple_46)

#### **Продвинутые вопросы**
1) [**В чем разница между теневым (Shadow) и виртуальным DOM?**](#react-advanced_1)
2) [**Что такое React Fiber?**](#react-advanced_2)
3) [**Для чего предназначен React Fiber?**](#react-advanced_3)
4) [**Что такое проп `children`?**](#react-advanced_4)
5) [**Как выглядят комментарии в React?**](#react-advanced_5)
6) [**Как определить состояние с помощью вычисляемого свойства?**](#react-advanced_6)
7) [**Какая распространенная ошибка приводит к вызову функции при каждом рендеринге?**](#react-advanced_7)
8) [**Поддерживают ли "ленивые" (lazy) функции именованный экспорт?**](#react-advanced_8)
9) [**Что такое портал (Portal) в React?**](#react-advanced_9)
10) [**Что такое предохранители (Error Boundaries) в React 16?**](#react-advanced_10)
11) [**Как реализовать предохранитель в React 15?**](#react-advanced_11)
12) [**Какой способ рекомендуется использовать для статической проверки типов?**](#react-advanced_12)
13) [**Для чего используется пакет `react-dom`?**](#react-advanced_13)
14) [**Для чего предназначен метод `render()` в `react-dom`?**](#react-advanced_14)
15) [**Что такое `ReactDOMServer`?**](#react-advanced_15)
16) [**Как использовать InnerHtml в React?**](#react-advanced_16)
17) [**Что произойдет при использовании `setState()` в `constructor()`?**](#react-advanced_17)
18) [**Почему следует избегать использования индексов в качестве ключей?**](#react-advanced_18)
19) [**Правильно ли использовать `setState()` в методе `componentWillMount()`?**](#react-advanced_19)
20) [**Что произойдет при использовании пропов в начальном состоянии (Initial State)?**](#react-advanced_20)
21) [**Как выполнить условный рендеринг компонентов?**](#react-advanced_21)
22) [**Почему следует быть осторожным при распространении (spread) пропов на DOM-элементы?**](#react-advanced_22)
23) [**Как использовать декораторы в React?**](#react-advanced_23)
24) [**Как запомнить или сохранить компонент?**](#react-advanced_24)
25) [**Как реализовать рендеринг на стороне сервера или SSR?**](#react-advanced_25)
26) [**Как включить производственный(production) режим в React?**](#react-advanced_26)
27) [**Что такое CRA(create-react-app) и в чем заключаются преимущества его использования?**](#react-advanced_27)
28) [**Назовите методы жизненного цикла, относящиеся к монтированию**](#react-advanced_28)
29) [**Какие методы жизненного цикла были признаны устаревшими в React 16?**](#react-advanced_29)
30) [**Для чего используется метод жизненного цикла `getDerivedStateFromProps()`?**](#react-advanced_30)
31) [**Для чего используется метод жизненного цикла `getSnapshotBeforeUpdate()`?**](#react-advanced_31)
32) [**Заменяют ли хуки рендер-пропы и компоненты высшего порядка?**](#react-advanced_32)
33) [**Как рекомендуется называть компоненты?**](#react-advanced_33)
34) [**Какой порядок расположения методов в классовом компоненте является рекомендуемым?**](#react-advanced_34)
35) [**Что такое компонент-переключатель (Switching Component)?**](#react-advanced_35)
36) [**Для чего в `setState()` передается функция?**](#react-advanced_36)
37) [**Что такое строгий режим в React?**](#react-advanced_37)
38) [**Что такое React-примеси (Mixins)?**](#react-advanced_38)
39) [**Почему `isMounted()` является антипаттерном? Назовите более подходящее решение**](#react-advanced_39)
40) [**Какие события указателя (Pointer Events) поддерживаются в React?**](#react-advanced_40)
41) [**Почему название компонента должно начинаться с большой буквы?**](#react-advanced_41)
42) [**Поддерживаются ли пользовательские DOM-атрибуты в React 16?**](#react-advanced_42)
43) [**В чем разница между `constructor()` и `getInitialState()`?**](#react-advanced_43)
44) [**Можно ли принудительно обновить компонент без вызова `setState()`?**](#react-advanced_44)
45) [**В чем разница между `super()` и `super(props)` в классовых компонентах React?**](#react-advanced_45)
46) [**Как реализовать цикл внутри JSX?**](#react-advanced_46)
47) [**Как получить доступ к пропам в закавыченных значениях атрибутов?**](#react-advanced_47)
48) [**Что такое массив React PropType с формой (shape)?**](#react-advanced_48)
49) [**Как реализовать условное применение классовых атрибутов?**](#react-advanced_49)
50) [**В чем разница между React и ReactDOM?**](#react-advanced_50)
51) [**Почему ReactDOM отделен от React?**](#react-advanced_51)
52) [**Как использовать элемент `label` в React?**](#react-advanced_52)
53) [**Как совместно использовать несколько встроенных объектов со стилями?**](#react-advanced_53)
54) [**Как повторно отрендерить слой представления при изменении размеров браузера?**](#react-advanced_54)
55) [**В чем разница между методами `setState()` и `replaceState()`?**](#react-advanced_55)
56) [**Как следить за изменением состояния компонента?**](#react-advanced_56)
57) [**Как рекомендуется удалять элемент из массива в состоянии React?**](#react-advanced_57)
58) [**Возможно ли использовать React без рендеринга HTML?**](#react-advanced_58)
59) [**Как красиво отобразить JSON с помощью React?**](#react-advanced_59)
60) [**Почему в React нельзя обновлять пропы?**](#react-advanced_60)
61) [**Как установить фокус на инпут при загрузке страницы?**](#react-advanced_61)
62) [**Какие существуют способы обновления объекта состояния?**](#react-advanced_62)
63) [**Как получить версию React при запуске приложения в браузере?**](#react-advanced_63)
64) [**Какие существуют подходы к добавлению полифилов в `create-react-app`?**](#react-advanced_64)
65) [**Как использовать https вместо http в `create-react-app`?**](#react-advanced_65)
66) [**Как избежать использования относительных путей при импорте в `create-react-app`?**](#react-advanced_66)
67) [**Как добавить Google Analytics в React Router?**](#react-advanced_67)
68) [**Как обновлять состояние компонента каждую секунду?**](#react-advanced_68)
69) [**Как применить вендорные префиксы во встроенных стилях в React?**](#react-advanced_69)
70) [**Как экспортировать/импортировать компоненты с помощью React и ES6?**](#react-advanced_70)
71) [**Почему конструктор компонента вызывается только один раз?**](#react-advanced_71)
72) [**Как в React определяются константы?**](#react-advanced_72)
73) [**Как программно вызвать возникновение события клика в React?**](#react-advanced_73)
74) [**Можно ли использовать `async/await` в обычном React?**](#react-advanced_74)
75) [**Назовите общую структуру директорий в React-проекте**](#react-advanced_75)
76) [**Назовите популярные библиотеки для работы с анимацией в React**](#react-advanced_76)
77) [**В чем заключаются преимущества использования модулей со стилями?**](#react-advanced_77)
78) [**Назовите популярные линтеры для React**](#react-advanced_78)
79) [**Как выполнить AJAX-запрос и в каком методе жизненного цикла это следует делать?**](#react-advanced_79)
80) [**Что такое рендер-пропы (Render Props)?**](#react-advanced_80)
***


### **Redux**
#### **Общие понятия**
1) [**Состояние (State)**](#redux-terms_1)
2) [**Экшен (Action)**](#redux-terms_2)
3) [**Редюсер (Reducer)**](#redux-terms_3)
4) [**Функция-диспетчер (Dispatching Function)**](#redux-terms_4)
5) [**Генератор экшена (Action Creator)**](#redux-terms_5)
6) [**Асинхронный экшен (Async Action)**](#redux-terms_6)
7) [**Мидлвар (Middleware)**](#redux-terms_7)
8) [**Стор (Store)**](#redux-terms_8)
9) [**Генератор стора (Store creator)**](#redux-terms_9)
10) [**Расширитель стора (Store enhancer)**](#redux-terms_10)

#### **Простые, общие вопросы**
1) [**Что такое Flux?**](#redux-simple_1)
2) [**Что такое Redux?**](#redux-simple_2)
3) [**Назовите ключевые принципы Redux**](#redux-simple_3)
4) [**В чем разница между контекстом React и React Redux?**](#redux-simple_4)
5) [**Для чего в Redux нужны константы?**](#redux-simple_5)
6) [**Что такое операция (action) в Redux?**](#redux-simple_6)
7) [**Можно ли запускать операцию(action) в редукторе?**](#redux-simple_7)
8) [**Как запустить операцию(action) при загрузке?**](#redux-simple_8)
9) [**Почему функции, изменяющие состояние, в Redux называются редукторами?**](#redux-simple_9)
10) [**Как установить начальное значение в Redux?**](#redux-simple_10)
11) [**Как получить доступ к хранилищу Redux за пределами компонента?**](#redux-simple_11)
12) [**Как рекомендуется получать доступ к хранилищу Redux?**](#redux-simple_12)
13) [**Как использовать метод `connect()` в Redux?**](#redux-simple_13)
14) [**Что такое селекторы (selectors) Redux и зачем их использовать?**](#redux-simple_14)
15) [**Как структурировать директории верхнего уровня в Redux?**](#redux-simple_15)
16) [**Обязательно ли хранить состояние всех компонентов в хранилище Redux?**](#redux-simple_16)
17) [**В чем разница между компонентом и контейнером в React Redux?**](#redux-simple_17)
18) [**Что такое Redux Form?**](#redux-simple_18)
19) [**Назовите основные возможности, предоставляемые Redux Form?**](#redux-simple_19)
20) [**Что такое Redux Thunk?**](#redux-simple_20)
21) [**Что такое Redux DevTools?**](#redux-simple_21)
22) [**Назовите основные возможности Redux DevTools**](#redux-simple_22)
23) [**Как добавить несколько middleware в Redux?**](#redux-simple_23)

#### **Продвинутые вопросы**
1) [**Проведите сравнение Redux и Flux**](#redux-advanced_1)
2) [**Назовите недостатки паттерна MVW (Model-View-Whatever: MVC, MVP, MVVM и т.д.**](#redux-advanced_2)
3) [**Существует ли что-либо общее между Redux и RxJS?**](#redux-advanced_3)
4) [**Как обнулить состояние в Redux?**](#redux-advanced_4)
5) [**Для чего используется символ *@* в декораторе `connect` Redux?**](#redux-advanced_5)
6) [**Как сделать AJAX-запрос в Redux?**](#redux-advanced_6)
7) [**В чем разница между `mapStateToProps()` и `mapDispatchToProps()`?**](#redux-advanced_7)
8) [**Какие способы существуют для написания `mapDispatchToProps()`?**](#redux-advanced_8)
9) [**Для чего используется параметр `ownProps` в методах `mapStateToProps()` и `mapDispatchToProps()`?**](#redux-advanced_9)
10) [**Что такое `redux-saga`?**](#redux-advanced_10)
11) [**Определите ментальную модель redux-saga**](#redux-advanced_11)
12) [**В чем разница между методами `call()` и `put()` в redux-saga?**](#redux-advanced_12)
13) [**В чем разница между `redux-saga` и `redux-thunk`?**](#redux-advanced_13)
14) [**Чем Relay отличается от Redux?**](#redux-advanced_14)
***

### **React Router**
#### **Простые, общие вопросы**
1) [**Что такое React Router?**](#react-router-simple_1)
2) [**Чем React Router отличается от библиотеки `history`?**](#react-router-simple_2)
3) [**Что такое `Router` в React Router 4?**](#react-router-simple_3)
4) [**Для чего предназначены методы `push()` и `replace()` объекта History?**](#react-router-simple_4)
5) [**Как реализовать программную навигацию с помощью React Router 4?**](#react-router-simple_5)
6) [**Как получить параметры строки запроса в React Router 4?**](#react-router-simple_6)
7) [**Когда можно получить предупреждение "Router может содержать только один дочерний элемент"?**](#react-router-simple_7)
8) [**Как передать параметры методу `history.push()` в React Router 4?**](#react-router-simple_8)
9) [**Как реализовать *стандартную* или *NotFound* страницу?**](#react-router-simple_9)
10) [**Как получить объект истории в React Router 4?**](#react-router-simple_10)
11) [**Как реализовать автоматическое перенаправление после выполнения входа в систему?**](#react-router-simple_11)
12) [**В чем отличие между `react-router`, `react-router-dom` и `react-router-native`?**](#react-router-simple_12)
***


## **React**
### **Простые, общие вопросы**
1) #### <a name="react-simple_1"></a> **Что такое реакт?**
    Реакт - это JavaScript-библиотека (не путать с фреймворком) для разработки пользовательского интерфейса.

2) #### <a name="react-simple_2"></a> **Как начать работать с реактом?**
    Самый простой способ попробовать реакт - использовать node.js (не ниже версии 10.16).
    Установка производится консольной командой: `npx create-react-app my-app`
    после чего нужно перейти в папку с проектом: `cd my-app`
    и запустить сервер: `npm start`.
    Чтобы собрать проект используется команда: `npm run build`.

3) #### <a name="react-simple_3"></a> **Какие особенности есть у ректа?**
    Реакт использует VirtualDOM вместо обычного DOM. Это позволяет повысить производительность, т.к. работа с обычным DOM требует больше ресурсов от компьютера.
    Поддержка SSR - Server Side Rendering (рендеринга на стороне сервера).
    Следование принципу однонаправленного потока или связывания данных. (Про однонаправленность можно почитать в официальной [документации](https://ru.reactjs.org/docs/state-and-lifecycle.html#the-data-flows-down))
    Использование модели компонентов. Компоненты - независимые части, которые можно переиспользовать в любом месте проекта.

4) #### <a name="react-simple_4"></a> **Что такое JSX?**
    Это смешанный синтаксис JavaScript и XML (JSX), который позволяет расширить возможности ECMAScript. По сути, это синтаксический сахар для функции `React.createElement()`.
    Подробнее рассказано в официальной [документации.](https://ru.reactjs.org/docs/introducing-jsx.html)

    Пример кода классовго компонента:
    ```jsx harmony
    class App extends React.Component {
      render() {
        return (
          <div>
            <h1>{'Добро пожаловать в мир React!'}</h1>
          </div>
        )
      }
    }
    ```

5) #### <a name="react-simple_5"></a> **Элемент и компонент, что это и как они различаются?**
    **Элемент** - это обычный объект, описывающий, что мы хотим увидеть на экране в терминах узлов и других частей DOM. *Элементы* могут содержать другие *элементы* в своих свойствах. Создавать *элементы* в React легко. После создания, *элемент* не подлежит изменению.
    
    Объектное представление React-элемента выглядит так:
    ```javascript
    const element = React.createElement(
      'div',
      {id: 'login-btn'},
      'Войти'
    )
    ```

    Функция `React.createElement()` возвращает такой объект:
    ```
    {
      type: 'div',
      props: {
        children: 'Войти',
        id: 'login-btn'
      }
    }
    ```

    Данный объект рендерится с помощью `ReactDOM.render()`:
    ```html
    <div id='login-btn'>Login</div>
    ```

    **Компонент** - это независимый блок кода, своеобразный кирпичик, который можно повторно использовать в любом месте вашего проекта.
    
    В отличие от элемента, *компонент* может определяться по-разному. Он может быть классом с методом `render()` (классовый компонент). Или же он может быть простой функцией (функциональный компонент). В любом случае, *компонент* принимает свойства (пропы, props от properties) на вход и возвращает JSX:

    ```javascript
    const Button = ({ onLogin }) =>
      <div id={'login-btn'} onClick={onLogin}>Войти</div>
    ```

    JSX транспилируется (преобразуется) в функцию `React.createElement()`:

    ```javascript
    const Button = ({ onLogin }) => React.createElement(
      'div',
      { id: 'login-btn', onClick: onLogin },
      'Войти'
    )
    ```
    
    В официальной документации можно более подробно почитать про [Элементы](https://ru.reactjs.org/docs/rendering-elements.html) и [Компоненты](https://ru.reactjs.org/docs/components-and-props.html).
    
6) #### <a name="react-simple_6"></a> **Как в реакте создаются компоненты?**
    Существует два способа это сделать:
    
    **Функциональные компоненты** - это простейший способ создания компонента. Эти функции являются "чистыми", принимают объект с пропами в качестве аргумента и возвращают элемент(ы):
    ```jsx harmony
    function Greeting({ message }) {
      return <h1>{`Привет, ${message}`}</h1>
    }
    ```

    **Классовые компоненты** - для определения компонента также можно использовать ES6-классы. Приведенный функциональный компонент может быть переписан следующим образом:
    ```jsx harmony
    class Greeting extends React.Component {
      render() {
        return <h1>{`Привет, ${this.props.message}`}</h1>
      }
    }
    ```
    
    **`Важно знать!`**
    Всегда именуйте компоненты с заглавной буквы. Имена с мальенькой буквы реакт примет за DOM-тег.
    
7) #### <a name="react-simple_7"></a> **Когда лучше использовать классовый компонент, а когда функциональный?**
    Если компонент нуждается в *состоянии или методах жизненного цикла*, тогда используйте классовый компонент, иначе, используйте функциональный компонент.
    
    **Обратите внимание:** в React 16.8 были представлены хуки, позволяющие использовать состояние, методы жизненного цикла и другие возможности классовых компонентов в функциях.
    
8) #### <a name="react-simple_8"></a> **Что такое "чистые" компоненты (Pure Components)?**
    `React.PureComponent` - это тоже самое, что `React.Component`, за исключением автоматической обработки метода `shouldComponentUpdate()`. При измнении пропсов или состояния `PureComponent` автоматически выполнит их поверхностное сравнение. С другой стороны, `Component` такого сравнения по умолчанию не проводит. Поэтому компонент будет повторно рендерится до тех пор, пока не будет вызван метод `shouldComponentUpdate()`.
    
    **`Важно знать!`**
    Метод `shouldComponentUpdate()` базового класса `React.PureComponent` делает только поверхностное сравнение объектов. Если они содержат сложные структуры данных, это может привести к неправильной работе компонента. Используйте `React.PureComponent` только с простыми пропсами и состоянием.
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/react-api.html#reactpurecomponent).
    
9) #### <a name="react-simple_9"></a> **Что такое состояние (state) в реакте?**
    *Состояние* - это объект, содержащий некоторую информацию, которая может измениться в течение жизненного цикла компонента. Мы всегда должны стараться делать состояние настолько простым, насколько это возможно, и минимизировать количество компонентов без состояния.

    Создадим компонент `User` с состоянием `message`:

    ```jsx harmony
    class User extends React.Component {
      state = {
        message: 'Добро пожаловать в мир React!'
      }

      render() {
        return (
          <div>
            <h1>{this.state.message}</h1>
          </div>
        )
      }
    }
    ```

    Состояние похоже на проп, но оно является приватным (замкнуто в своей области видимости) и полностью контролируется компонентом, т.е. оно недоступно для других компонентов, кроме того, которому оно принадлежит и которое его определяет.
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/state-and-lifecycle.html).
    
10) #### <a name="react-simple_10"></a> **Что такое пропcы (props) в реакте?**
    *Props (сокр. от properties)* - это входные данные для компонента. Это простые значения (примитивы) или объект, содержащий несколько значений, которые передаются компонентам при их создании с помощью синтаксиса, похожего на атрибуты HTML-тегов.
    
    Основное назначение пропсов в реакте заключается в предоставлении компоненту следующего функционала:
    
    - Передача данных компоненту
    - Вызов изменения состояния
    - Использование через `this.props.reactProp` внутри метода `render()` компонента
    
    Создадим элемент со свойством `reactProp`:
    ```jsx harmony
    <Element reactProp={'1'} />
    ```
    Этот `reactProp` добавляется в качестве свойства ко встроенному объекту *props*, который присутствет во всех компонентах, созданных с помощью реакта. Получение данных не отличается от работы с обычным объектом:
    ```
    props.reactProp
    ```

11) #### <a name="react-simple_11"></a> **В чем разница между состоянием и пропсами?**
    И *props*, и *state* являются обычными JavaScript-объектами. Несмотря на то, что они оба содержат информацию, которая используется при рендеринге компонента, функционал у них разный. Пропсы передаются компоненту подобно аргументам, передаваемым функции, а состояние управляется компонентом как переменные, объявленные внутри функции.
    
12) #### <a name="react-simple_12"></a> **Почему не следует обновлять состояние напрямую?**
    Если вы попытаетесь обновить состояние напрямую, компонент не будет обновлён:
    ```javascript
    // Неправильно
    this.state.message = 'Привет, народ'
    ```

    Вместо этого, следует использовать метод `setState()`. Он планирует (откладывает) обновление состояния компонента. Когда состояние меняется, компонент перерисовывается:
    ```javascript
    // Правильно
    this.setState({ message: 'Привет, народ' })
    ```

    **`Важно знать!`**
    Состояние компонента можно изменять напрямую в `constructor()` или с помощью нового синтаксиса определения полей классов (без создания коструктора и ключевого слова `this`).
    
13) #### <a name="react-simple_13"></a> **Для чего передаётся коллбэк вторым аргументом в `setState()`?**
    Коллбэк вызывается после выполнения `setState()` и рендеринга компонента. Поскольку метод `setState()` является *асинхронным*, коллбек используется для выполнения любых "последующих" операций.

    ```javascript
    setState({ name: 'Иван' }, () => console.log(`Свойство "name" обновлено и компонент повторно отрисован`))
    ```

    **`Важно знать!`**
    Вместо таких коллбэков рекомендуется использовать componentDidUpdate().
    
14) #### <a name="react-simple_14"></a> **В чем разница между обработкой событий в HTML и React?**
    Ниже приведены некоторые из основных отличий:
    - В HTML название события указывается строчными буквами (в *нижнем регистре*):
        ```html
        <button onclick='activateLasers()'>
        ```
        
       В React для этого используется "верблюжий стиль" (camelCase):
        ```jsx harmony
        <button onClick={activateLasers}>
        ```

    - В HTML можно вернуть `false` для предотвращения поведения по умолчанию:
        ```html
        <a href='#' onclick='console.log("Ссылка была нажата"); return false;' />
        ```

       В React необходимо явно вызывать метод `preventDefault()`:
        ```javascript
        function handleClick(event) {
          event.preventDefault()
          console.log('Ссылка была нажата')
        }
        ```

    - В HTML необходимо вызывать функцию с помощью `()`
      В React этого делать не нужно.
      
15) #### <a name="react-simple_15"></a> **Как в коллбеках JSX привязываются методы или обработчики событий?**
    Существует 3 способа это сделать:
    
    - **Привязка в конструкторе:** в классах JavaScript методы не связаны с экземплярами по умолчанию. Тоже самое справедливо для обработчиков событий в React. Обычно, мы делаем привязку в конструкторе:
        ```javascript
        class Component extends React.Component {
          constructor(props) {
            super(props)
            this.handleClick = this.handleClick.bind(this)
          }

          handleClick() {
            // ...
          }
        }
        ```

    - **Синтаксис публичных полей класса:** если вам не нравится использовать `bind()`, для привязки коллбеков можно использовать *синтаксис публичных полей класса*:

        ```jsx harmony
        handleClick = () => {
          console.log('Это: ', this)
        }
        ```
        ```jsx harmony
        <button onClick={this.handleClick}>
          Нажми на меня
        </button>
        ```

    - **Стрелочные функции:** вы также можете использовать *стрелочные функции* прямо в коллбеках:
        ```jsx harmony
        <button onClick={(event) => this.handleClick(event)}>
          Нажми на меня
        </button>
        ```

    **`Важно знать!`**
    Eсли коллбек передается в качестве пропа дочерним компонентам, это может привести к ненужному повторному рендерингу. В таких случаях, рекомендуется использовать `bind()` или *синтаксис публичных полей класса* для улучшения производительности.

16) #### <a name="react-simple_16"></a> **Как передать аргумент в "коллбек" или обработчик событий?**
    Для этого можно использовать *стрелочную функцию* в качестве обертки для *обработчика событий*:
    ```jsx harmony
    <button onClick={() => this.handleClick(id)} />
    ```

    Это эквивалентно вызову `bind()`:
    ```jsx harmony
    <button onClick={this.handleClick.bind(this, id)} />
    ```

    Кроме названных подходов, вы также можете передавать аргументы в стрелочную функцию:
    ```jsx harmony
    <button onClick={this.handleClick(id)} />
    handleClick = (id) => () => {
        console.log("Здравствуйте, номер вашего билета: ", id)
    };
    ```
    
17) #### <a name="react-simple_17"></a> **Что такое синтетические события в реакте?**
    `SyntheticEvent` - это кроссбраузерная оболочка для нативных событий браузера. Этот API аналогичен браузерному, включая `stopPropagation()` и `preventDefault()`, но работает одинаково во всех браузерах.
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/events.html).
    
18) #### <a name="react-simple_18"></a> **Что такое условный рендеринг?**

    Для условного рендеринга можно использовать обычные *if* или *тернарные операторы*. Кроме того, вы можете встраивать в JSX любое выражение посредством оборачивания его в фигурные скобки, а также совместно с логическим оператором `&&` (короткие вычисления).

    ```jsx harmony
    <h1>Привет!</h1>
    {
        messages.length > 0 && !isLogin
          ? <h2>У вас {messages.length} непрочитанных сообщений.</h2>
          : <h2>У вас нет непрочитанных сообщений.</h2>
    }
    ```

    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/conditional-rendering.html).

19) #### <a name="react-simple_19"></a> **Что такое пропс `key` и в чем заключаются преимущества его использования?**
    `key` - это специальный строковый атрибут, который вы *должны* использовать при создании списков элементов. Проп `key` помогает реакту определять, какие элементы подверглись изменениям, были добавлены или удалены.

    Чаще всего, в качестве *ключа* мы используем идентификаторы:
    ```jsx harmony
    const todoItems = todos.map((todo) =>
      <li key={todo.id}>
        {todo.text}
      </li>
    )
    ```

    При отсутствии ID, в крайнем случае, в качестве *ключа* можно использовать *индекс элемента*:
    ```jsx harmony
    const todoItems = todos.map((todo, index) =>
      <li key={index}>
        {todo.text}
      </li>
    )
    ```

    **`Важно знать!`**
    - Использовать *индексы* в качестве ключей *не рекомендуется*, если порядок расположения элементов может измениться. Это может негативно сказаться на производительности, а также привести к проблемам с состоянием компонента.
    - При извлечении элемента списка в качестве самостоятельного компонента применяйте *ключи* к этим компонентам, а не к тегу `li`.
    - При отсутствии пропса `key` в консоль будет выведено соответствующее предупреждение.
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/lists-and-keys.html#keys).

20) #### <a name="react-simple_20"></a> **Для чего используются ссылки (рефы, refs)?**
    `ref` возвращает ссылку на DOM-элемент. Этого в большинстве случаев *следует избегать*. Тем не менее, ссылки могут быть полезны при необходимости получения прямого доступа к DOM-элементу или экземпляру компонента.
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/refs-and-the-dom.html).

21) #### <a name="react-simple_21"></a> **Как создаются рефы?**
    Существует два подхода:
    - Это новый подход. *Ссылки* создаются с помощью `React.createRef()` и привязываются к элементу через `ref`. Для того, чтобы иметь возможность использовать *рефы* во всем компоненте, просто присвойте `ref` свойству экземпляра в конструкторе:
        ```jsx harmony
        class MyComponent extends React.Component {
          constructor(props) {
            super(props)
            this.myRef = React.createRef()
          }
          
          render() {
            return <div ref={this.myRef} />
          }
        }
        ```

    - Также можно использовать реф-коллбеки (callback refs). Например, доступ к полю для ввода текста поисковой строки можно получить следующим образом:
        ```jsx harmony
        class SearchBar extends Component {
           constructor(props) {
              super(props);
              this.txtSearch = null;
              this.state = { term: '' };
              this.setInputSearchRef = e => {
                 this.txtSearch = e;
              }
           }
           
           onInputChange(event) {
              this.setState({ term: this.txtSearch.value });
           }
           
           render() {
              return (
                 <input
                    value={this.state.term}
                    onChange={this.onInputChange.bind(this)}
                    ref={this.setInputSearchRef} />
              );
           }
        }
        ```
        
    Вы также можете использовать *рефы* в функциональных компонентах с помощью *замыканий* или хука `useRef()`.

    **`Важно знать!`**
    Использовать встроенные реф-коллбеки не рекомендуется.
    
22) #### <a name="react-simple_22"></a> **Что такое передача ссылки (Forward Ref)?**
    *Передача ссылки* - это "фича" (feature - возможность, способность), которая позволяет компонентам принимать *реф* и передавать его потомкам:
    ```jsx harmony
    const ButtonElement = React.forwardRef((props, ref) => (
      <button ref={ref} className="CustomButton">
        {props.children}
      </button>
    ));

    // Создаем ссылку на кнопку
    const ref = React.createRef();
    <ButtonElement ref={ref}>Передать ссылку</ButtonElement>
    ```
    
23) #### <a name="react-simple_23"></a> **Что лучше использовать, "коллбек-рефы" или `findDOMNode()`?**
    Лучше использовать *callback refs* вместо API `findDOMNode()`. Это объясняется тем, что `findDOMNode()` препятствует будущим улучшениям React.
    
    *Типичный* пример использования `findDOMNode()`:
    ```javascript
    class MyComponent extends Component {
      componentDidMount() {
        findDOMNode(this).scrollIntoView()
      }

      render() {
        return <div />
      }
    }
    ```

    Рекомендуемый подход:
    ```javascript
    class MyComponent extends Component {
      constructor(props){
        super(props);
        this.node = createRef();
      }
      
      componentDidMount() {
        this.node.current.scrollIntoView();
      }

      render() {
        return <div ref={this.node} />
      }
    }
    ```
    
24) #### <a name="react-simple_24"></a> **Что такое виртуальный DOM?**
    *Virtual DOM* (VDOM) - это представление *Real DOM*("настоящий" DOM), хранимое в оперативной памяти. Это представление синхронизируется с "настоящим" DOM. Сравнение происходит между вызовом функции рендеринга и отображением элемента на экране. Данный внутренний процесс называется *reconciliation* (согласованием).
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/react-dom.html).
    
25) #### <a name="react-simple_25"></a> **Как работает виртуальный DOM?**
    *Virtual DOM* работает следующим образом:

    - При любом изменении внутренних данных пользовательский интерфейс меняется в представлении виртуального DOM.
    - Затем вычисляется разница между предыдущим и новым представлениями.
    - После этого обновляются только те части реального DOM, которые подверглись изменениям.
    
    Визуальное оформление процесса можно посмотреть [тут](https://github.com/TanikoM/React-Questions#24).
    
26) #### <a name="react-simple_26"></a> **Что такое управляемые компоненты?**
    Компоненты, которые управляют инпутами формы для текущего пользователя, называются *управляемыми*. Любое изменение состояния имеет соответствующий обработчик.

    Например, для того, чтобы значение было представлено прописными буквами (в *верхнем регистре*), мы используем такой обработчик:
    ```javascript
    handleChange(event) {
      this.setState({value: event.target.value.toUpperCase()})
    }
    ```
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/forms.html#controlled-components).
    
27) #### <a name="react-simple_27"></a> **Что такое неуправляемые компоненты?**
    *Неуправляемые компоненты* - это компоненты, которые хранят собственное состояние, при необходимости получить их текущее значение используются ссылки на DOM-элементы. Это больше похоже на обычный HTML.

    В приведенном ниже примере мы получаем доступ к полю для ввода имени по ссылке:
    ```jsx harmony
    class UserProfile extends React.Component {
      constructor(props) {
        super(props)
        this.handleSubmit = this.handleSubmit.bind(this)
        this.input = React.createRef()
      }

      handleSubmit(event) {
        alert('Было отправлено имя: ' + this.input.current.value)
        event.preventDefault()
      }

      render() {
        return (
          <form onSubmit={this.handleSubmit}>
            <label>
              Имя:
              <input type="text" ref={this.input} />
            </label>
            <input type="submit" value="Submit" />
          </form>
        );
      }
    }
    ```
    
    Для обработки форм рекомендуется использовать управляемые компоненты.
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/uncontrolled-components.html).
    
28) #### <a name="react-simple_28"></a> **В чем разница между `createElement()` и `cloneElement()`?**
    JSX транспилируется в функции `createElement()` для создания элементов React, которые используются для объектного представления пользовательского интерфейса. А `cloneElement()` используется для клонирования элемента и передачи ему новых свойств.
    
    Подробнее можно узнать в официальной документации [createElement()](https://ru.reactjs.org/docs/react-api.html#createelement), [cloneElement()](https://ru.reactjs.org/docs/react-api.html#cloneelement).
    
29) #### <a name="react-simple_29"></a> **Что такое подъём состояния в реакте?**
    Когда несколько компонентов нуждаются в использовании одних и тех же изменяющихся данных, рекомендуется *поднимать совместно используемое состояние* до ближайшего общего предка. Это означает, что если два дочерних компонента используют одинаковые данные, следует поднять состояние к их родителю вместо дублирования состояния в каждом потомке.

    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/lifting-state-up.html).
    
30) #### <a name="react-simple_30"></a> **Назовите стадии жизненного цикла компонента**
    Жизненный цикл компонента состоит из 3 стадий:
    1. **Монтирование:** компонент готов к встраиванию в браузерный DOM. Эта стадия охватывает инициализацию в `constructor()`, а также методы жизненного цикла `getDerivedStateFromProps()`, `render()` и `componentDidMount()`.
    
    2. **Обновление:** на данной стадии компонент обновляется либо из-за получения новых пропов, либо из-за обновления состояния с помощью `setState()` или `forceUpdate()`. Эта стадия охватывает такие методы жизненного цикла как `getDerivedStateFromProps()`, `shouldComponentUpdate()`, `render()`, `getSnapshotBeforeUpdate()` и `componentDidUpdate()`.

    3. **Размонтирование:** на этой последней стадии компонент удаляется из браузерного DOM. Данная стадия включает метод жизненного цикла `componentWillUnmount()`.

    Следует отметить, что в React также имеются особые стадии применения изменений к DOM:
    1. **Рендеринг:** компонент рендерится без каких-либо побочных эффектов. Это применяется в отношении "чистых" компонентов. На данной стадии React может приостанавливать, прерывать или перезапускать рендеринг.

    2. **Pre-commit:** перед обновлением компонента есть момент, когда React читает DOM через `getSnapshotBeforeUpdate()`.

    3. **Commit:** React изменяет DOM и выполняет завершающие методы жизненного цикла, такие как `componentDidMount()` при монтировании, `componentDidUpdate()` при обновлении и `componentWillUnmount()` при размонтировании.

    Стадии в реакте до версии 16.3 и после 16.3, отличаются. Их можно посмотреть в [диаграмме](https://github.com/TanikoM/React-Questions#32).
    
31) #### <a name="react-simple_31"></a> **Назовите методы жизненного цикла в React**
    До версии 16.3:
    - **componentWillMount:** выполняется перед рендерингом для настройки корневого компонента на уровне приложения
    - **componentDidMount:** выполняется после первого рендеринга, здесь выполняются AJAX-запросы, обновляется DOM или состояние компонента, регистрируются обработчики событий
    - **componentWillReceiveProps:** выполняется при обновлении определенного пропа для запуска перехода состояния
    - **shouldComponentUpdate:** определяет, должен ли компонент обновляться. Значением по умолчанию является `true`. Если вы уверены в том, что компонент не нуждается в повторном рендеринге при изменении состояния или пропов, тогда можете вернуть ложное значение. Это подходящее место для улучшения производительности, позволяющее предотвратить ненужные рендеринги при получении компонентом новых пропов
    - **componentWillUpdate:** выполняется перед повторным рендерингом компонента при изменении состояния или пропов и при истинном значении, возвращаемом `shouldComponentUpdate()`
    - **componentDidUpdate:** в основном, используется для обновления DOM в соответствии с изменениями состояния или пропов
    - **componentWillUnmount:** используется для отмены сетевых запросов или удаления обработчиков событий, связанных с компонентом

    После версии 16.3:
    - **getDerivedStateFromProps:** запускается перед вызовом метода `render()` и при каждом повторном рендеринге. Он используется в редких случаях, когда нам требуется производное состояние. Для получения более подробной информации смотрите [если вам требуется производное состояние](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html)
    - **componentDidMount:** выполняется после первого рендеринга, здесь выполняются AJAX-запросы, обновляется DOM или состояние компонента, регистрируются обработчики событий
    - **shouldComponentUpdate:** определяет, должен ли компонент обновляться. Значением по умолчанию является `true`. Если вы уверены в том, что компонент не нуждается в повторном рендеринге при изменении состояния или пропов, тогда можете вернуть ложное значение. Это подходящее место для улучшения производительности, позволяющее предотвратить ненужные рендеринги при получении компонентом новых пропов
    - **getSnapshotBeforeUpdate:** выполняется перед применением результатов рендеринга к DOM. Любое значение, возвращенное этим методом, передается в `componentDidUpdate()`. Это может быть полезным для получения информации из DOM, например, позиции курсора или величины прокрутки
    - **componentDidUpdate:** в основном, используется для обновления DOM в соответствии с изменением состояния или пропов. Не выполняется, если `shouldComponentUpdate()` возвращает `false`
    - **componentWillUnmount** используется для отмены сетевых запросов или удаления обработчиков событий, связанных с компонентом
    
32) #### <a name="react-simple_32"></a> **Что такое компонент высшего порядка (Higher Order Component, HOC)?**
    *Higher-order component* (HOC) - это функция, принимающая компонент и возвращающая новый компонент. Это паттерн, производный от композиционной природы React.

    Мы называем такие компоненты *чистыми*, поскольку они могут принимать и динамически предоставлять дочерние компоненты, но не меняют и не копируют их поведение.
    ```javascript
    const EnhancedComponent = higherOrderComponent(WrappedComponent)
    ```

    HOC, обычно, используются для:
    - Обеспечения возможности переиспользования кода, логики, а также для абстрагирования шаблонов
    - Отложенного рендеринга
    - Абстрагирования и манипулирования состоянием
    - Манипулирования пропами
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/higher-order-components.html).
    
33) #### <a name="react-simple_33"></a> **Как в HOC-компоненте создаются прокси для пропcов?**
    Вы можете добавлять/редактировать пропcы, передаваемые в компонент, с помощью шаблона *проксирования пропов* следующим образом:
    ```jsx harmony
    function HOC(WrappedComponent) {
      return class Test extends Component {
        render() {
          const newProps = {
            title: 'Новый заголовок',
            footer: false,
            showFeatureX: false,
            showFeatureY: true
          }

          return <WrappedComponent {...this.props} {...newProps} />
        }
      }
    }
    ```
    
34) #### <a name="react-simple_34"></a> **Что такое контекст (Context)?**
    *Context* предоставляет возможность передавать данные в дереве компонента без необходимости передачи пропов на каждом уровне вручную.

    Например, статус аутентификации пользователя, языковые предпочтения или цветовая схема могут использоваться многими компонентами приложения:
    ```javascript
    const { Provider, Consumer } = React.createContext(defaultValue)
    ```
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/context.html).
    
35) #### <a name="react-simple_35"></a> **Для чего используется ключевое слово `super` с аргументом `props` в конструкторе?**
    Конструктор дочернего класса не может использовать ссылку на `this` до вызова метода `super()`. Тоже самое справедливо для ES6-подклассов. Основная причина передачи аргумента `props` в `super()` состоит в обеспечении возможности доступа к `this.props` в дочернем конструкторе.

    **Передача пропов:**
    ```javascript
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)

        console.log(this.props) // вывод: { name: 'Иван', age: 30 }
      }
    }
    ```

    **Без пропов:**
    ```javascript
    class MyComponent extends React.Component {
      constructor(props) {
        super()

        console.log(this.props) // вывод: undefined

        // однако, пропы по-прежнему доступны как в конструкторе, ...
        console.log(props) // вывод: { name: 'Иван', age: 30 }
      }

      render() {
        // так и за его пределами
        console.log(this.props) // вывод { name: 'Иван', age: 30 }
      }
    }
    ```
    
36) #### <a name="react-simple_36"></a> **Что такое согласование?**
    Когда изменяется состояние или пропы компонента, React определяет, нуждается ли DOM в обновлении посредством сравнения нового элемента с предыдущим. Когда эти элементы отличаются, React обновляет DOM. Данный процесс называется *reconciliation*.

37) #### <a name="react-simple_37"></a> **Почему в React используется `className` вместо атрибута `class`?**
    `class` - это одно из ключевых слов JavaScript, а JSX - это расширение JavaScript. Вот почему в React вместо `class` используется `className`. В качестве пропа `className` передается строка:

    ```jsx harmony
    render() {
      return <span className={'menu navigation-menu'}>Меню</span>
    }
    ```
    
38) #### <a name="react-simple_38"></a> **Что такое фрагмент (Fragment)?**
    Это распространенный паттерн в React, который используется в компонентах, возвращающих несколько элементов. *Fragments* позволяют группировать дочерние элементы без создания лишних DOM-узлов:
    ```jsx harmony
    render() {
      return (
        <React.Fragment>
          <ChildA />
          <ChildB />
          <ChildC />
        </React.Fragment>
      )
    }
    ```

    Также существует *сокращенный синтаксис*, но он не поддерживается в некоторых инструментах:
    ```jsx harmony
    render() {
      return (
        <>
          <ChildA />
          <ChildB />
          <ChildC />
        </>
      )
    }
    ```
    
39) #### <a name="react-simple_39"></a> **Почему фрагменты лучше, чем `div`?**
    Вот некоторые причины:

    - Фрагменты немного быстрее и используют меньше памяти. Реальная польза от этого ощущается в очень больших и глубоких деревьях элементов.
    - Некоторые механизмы CSS, например, *Flexbox* и *Grid* используют связь родитель-ребенок (предок-потомок, если угодно), поэтому добавление дополнительных `div` может сломать макет страницы.
    - Удобнее пользоваться инспектором DOM.
    
40) #### <a name="react-simple_40"></a> **Что такое компонент без состояния?**
    Если поведение компонента не зависит от его состояния, такой компонент считается не имеющим состояния. Для создания компонентов без состояния можно использовать как функции, так и классы. Однако, если вам не нужны методы жизненного цикла, тогда лучше использовать функциональные компоненты. У функция по сравнению с классами в этом случае имеется несколько преимуществ: их легче писать, читать и тестировать, они немного быстрее и в них не требуется использовать ключевое слово `this`.
    
41) #### <a name="react-simple_41"></a> **Что такое компонент с состоянием?**
    Если поведение компонента зависит от состояния, такой компонент считается имеющим состояние. Раньше компоненты с состоянием можно было создавать только с помощью классов. Сейчас хуки предоставляют возможность создавать функциональные компоненты с состоянием. В классах состояние инициализируется в `constructor()` с помощью `this.state = initialValue`, в функции, как правило, в начале с помощью `const [state, setState] = useState(initialValue)`.
    
    Классовый компонент:
    ```javascript
    class App extends Component {
      constructor(props) {
        super(props)
        this.state = { count: 0 }
      }

      render() {
        // ...
      }
    }
    ```
    
    **Начиная с версии 16.8:**
    Эквивалентный функциональный компонент с использованием хука `useState()`:

       ```javascript
        import React, { useState } from 'react';

        const App = (props) => {
          const [count, setCount] = useState(0);

          return (
            // ...
          )
        }
       ```
       
42) #### <a name="react-simple_42"></a> **Как осуществить проверку пропов в React?**
    При запуске приложения в *режиме для разработки*, React автоматически проверяет все пропы, определенные в компонентах, на *правильные типы*. Если тип является неправильным, React выводит в консоль предупреждение. Эта проверка отключена в *режиме для продакшна* с целью повышения производительности. Обязательные пропы определяются с помощью `isRequired`.

    Набор предопределенных типов пропов:
    1. `PropTypes.number`
    2. `PropTypes.string`
    3. `PropTypes.array`
    4. `PropTypes.object`
    5. `PropTypes.func`
    6. `PropTypes.node`
    7. `PropTypes.element`
    8. `PropTypes.bool`
    9. `PropTypes.symbol`
    10. `PropTypes.any`

    Мы можем определить `propTypes` для компонента `User` следующим образом:
    ```jsx harmony
    import React from 'react'
    import PropTypes from 'prop-types'

    class User extends React.Component {
      static propTypes = {
        name: PropTypes.string.isRequired,
        age: PropTypes.number.isRequired
      }

      render() {
        return (
          <>
            <h1>{`Добро пожаловать, ${this.props.name}`}</h1>
            <h2>{`Возраст, ${this.props.age}`}</h2>
          </>
        )
      }
    }
    ```

    **`Важно знать!`**
    В React 15.5 *PropTypes* были перемещены из `React.PropTypes` в библиотеку `prop-types`.
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/typechecking-with-proptypes.html).
    
43) #### <a name="react-simple_43"></a> **Какие преимущества предоставляет использование React?**
    Вот список основных преимуществ:
    1. Повышение производительности приложения благодаря *виртуальному DOM*.
    2. *JSX* облегчает написание и чтение кода.
    3. Возможность рендеринга как на стороне клиента, так и на стороне сервера.
    4. Возможность относительно простой интеграции с фреймворками (Angular, Backbone), поскольку React - это всего лишь библиотека.
    5. Возможность быстрого юнит и интеграционного тестирования с помощью таких инструментов, как Jest.
    
44) #### <a name="react-simple_44"></a> **Какие ограничения имеются в React?**
    Кроме преимуществ, в React существуют некоторые ограничения:
    1. React - это всего лишь библиотека, отвечающая за слой представления, а не полноценный фреймворк.
    2. Его трудно изучать новичкам в веб-разработке.
    3. Интеграция с традиционными MVC-фреймворками требует дополнительной настройки.
    4. Код является более сложным из-за встроенных шаблонов и JSX.
    5. Большое количество мелких компонентов приводит к сложности в проектировании и построении архитектуры приложения.
    
45) #### <a name="react-simple_45"></a> **Как использовать стили в React?**
    Атрибут `style` принимает объект JavaScript со свойствами в стиле *camelCase*, а не в виде CSS-строки. Это обеспечивает согласованность с JavaScript-свойствами, связанными со стилями, является более эффективным и закрывает дыры в безопасности (XSS).

    ```jsx harmony
    const divStyle = {
      color: 'blue',
      backgroundImage: 'url(' + imgUrl + ')'
    };

    function HelloWorldComponent() {
      return <div style={divStyle}>Привет, народ!</div>
    }
    ```

    Стили пишутся в camelCase для интеграции со свойствами узлов DOM в JavaScript (например, `node.style.backgroundImage`).
    
46) #### <a name="react-simple_46"></a> **Чем отличаются события в React?**
    Обработка событий в элементах React имеет некоторые синтаксические отличия:
    1. Обработчики событий именуются в верблюжьем стиле, а не в нижнем регистре.
    2. В JSX в обработчик передается функция, а не строка (функция передается как ссылка, т.е. не вызывается).
***


### **Продвинутые вопросы**
1) #### <a name="react-advanced_1"></a> **В чем разница между теневым (Shadow) и виртуальным DOM?**
    *Shadow DOM* - это браузерная технология, спроектированная для ограничения области видимости переменных и CSS в *веб-компонентах*. *Virtual DOM* - это концепция, реализуемая некоторыми библиотеками JavaScript поверх браузерных API.

2) #### <a name="react-advanced_2"></a> **Что такое React Fiber?**
    *Fiber* (волокно) - это новый движок *согласования*, изменение основного алгоритма в React 16. Основной задачей React Fiber является повышения производительности в таких областях, как анимация, создание макета страницы, обработка жестов, возможность приостанавливать, прерывать или повторно запускать выполнение операций, предоставление приоритета определенным типам обновлений, а также новые примитивы параллелизма.
    
3) #### <a name="react-advanced_3"></a> **Для чего предназначен React Fiber?**
    Цель *React Fiber* - повышение производительности в таких областях, как анимация, создание макета страницы и обработка жестов. Основной его особенностью является *incremental rendering* (инкрементальный рендеринг, используется Angular): возможность разделения процесса рендеринга на части и их объединение через различные фреймы.
    
4) #### <a name="react-advanced_4"></a> **Что такое проп `children`?**
    *Потомки* (дети) - это проп (`this.props.children`), позволяющий передавать одни компоненты другим, как любые другие пропы. Дерево компонентов, размещаемое между открывающим и закрывающим тегами, передается компоненту в качестве пропа `children`.

    Для работы с этим пропом в React API существуют такие методы как: `React.Children.map`, `React.Children.forEach`, `React.Children.count`, `React.Children.only` и `React.Children.toArray`.

    Простой пример использования пропа `children`:
    ```jsx harmony
    const MyDiv = React.createClass({
      render: function() {
        return <div>{this.props.children}</div>
      }
    })

    ReactDOM.render(
      <MyDiv>
        <span>Привет, </span>
        <span>народ</span>
      </MyDiv>,
      node
    )
    ```
    
5) #### <a name="react-advanced_5"></a> **Как выглядят комментарии в React?**
    Комментарии в React/JSX похожи на многострочные комментарии JavaScript, но оборачиваются в фигурные скобки:

    **Однострочные комментарии:**
    ```jsx harmony
    <div>
      {/* Однострочный комментарий (в ванильном JavaScript однострочные комментарии помещаются после двойного слеша (//)) */}
      {`Добро пожаловать, ${user}. Давайте изучать React`}
    </div>
    ```

    **Многострочные комментарии:**
    ```jsx harmony
    <div>
      {/* Комментарий, состоящий из
       нескольких строк */}
      {`Добро пожаловать, ${user}. Давайте изучать React`}
    </div>
    ```
    
6) #### <a name="react-advanced_6"></a> **Как определить состояние с помощью вычисляемого свойства?**
    При использовании ES6 или транспилятора Babel для преобразования JSX-кода вы можете применять *вычисляемые названия свойств*:

    ```javascript
    handleInputChange(event) {
      this.setState({ [event.target.id]: event.target.value })
    }
    ```
    
7) #### <a name="react-advanced_7"></a> **Какая распространенная ошибка приводит к вызову функции при каждом рендеринге?**
    При передаче функции в качестве аргумента необходимо убедиться, что она не вызывается:
    ```jsx harmony
    render() {
      // Неправильно: handleClick вызывается вместо передачи в качестве ссылки!
      return <button onClick={this.handleClick()}>Нажми на меня</button>
    }
    ```

    Вместо этого, следует передавать саму функцию, без круглых скобок:
    ```jsx harmony
    render() {
      // Правильно: handleClick передается как ссылка!
      return <button onClick={this.handleClick}>Нажми на меня</button>
    }
    ```
    
8) #### <a name="react-advanced_8"></a> **Поддерживают ли "ленивые" (lazy) функции именованный экспорт?**
    Нет, функция `React.lazy()` поддерживает только экспорт по умолчанию. Если вы хотите импортировать модуль с помощью именованного импорта, то можете создать промежуточный модуль, который будет повторно экспортировать этот модуль по умолчанию. Это также позволит выполнять свою работу *тряске дерева* (tree shaking) и предотвратит загрузку неиспользуемых компонентов.

    Рассмотрим файл компонента, в котором по имени импортируется несколько компонентов:
    ```javascript
    // MoreComponents.js
    export const SomeComponent = /* ... */;
    export const UnusedComponent = /* ... */;
    ```

    Затем компоненты из `MoreComponents.js` повторно экспортируются в промежуточном файле `IntermediateComponent.js`:
    ```javascript
    // IntermediateComponent.js
    export { SomeComponent as default } from "./MoreComponents.js";
    ```

    После этого, компоненты могут импортироваться с помощью "ленивой" функции:
    ```javascript
    import React, { lazy } from 'react';
    const SomeComponent = lazy(() => import("./IntermediateComponent.js"));
    ```

    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/react-api.html#reactlazy).
    
9) #### <a name="react-advanced_9"></a> **Что такое портал (Portal) в React?**
    *Portal* - рекомендуемый способ рендеринга потомков в DOM-узле, который находится за пределами родительского компонента:
    ```javascript
    ReactDOM.createPortal(child, container)
    ```

    Первый аргумент - любой React-компонент, подлежащий рендерингу, такой как элемент, строка или фрагмент. Второй аргумент - DOM-элемент.
    
10) #### <a name="react-advanced_10"></a> **Что такое предохранители (Error Boundaries) в React 16?**
    *Error boundaries*- это компоненты, которые отлавливают ошибки JavaScript, возникающие в любом дочернем компоненте, сообщают об этих ошибках и отображают резервный UI.

    Классовый компонент становится предохранителем при определении в нем нового метода жизненного цикла `componentDidCatch(error, info)` или `static getDerivedStateFromError() `:
    ```jsx harmony
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props)
        this.state = { hasError: false }
      }

      componentDidCatch(error, info) {
        // Вы также можете отправлять ошибки в специальный сервис по их обработке
        logErrorToMyService(error, info)
      }

      static getDerivedStateFromError(error) {
         // Обновляем состояние, чтобы при следующем рендеринге использовался запасной UI
         return { hasError: true };
       }

      render() {
        if (this.state.hasError) {
          // Вы можете рендерить любой резервный интерфейс
          return <h1>{'Что-то пошло не так.'}</h1>
        }
        return this.props.children
      }
    }
    ```

    После этого, предохранитель используется как обычный компонент:
    ```jsx harmony
    <ErrorBoundary>
      <MyWidget />
    </ErrorBoundary>
    ```
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/error-boundaries.html#introducing-error-boundaries).
    
11) #### <a name="react-advanced_11"></a> **Как реализовать предохранитель в React 15?**
    React 15 предоставляет поддержку для *error boundaries* с помощью метода `unstable_handleError()`. Данный метод был переименован в `componentDidCatch()` в React 16.
    
12) #### <a name="react-advanced_12"></a> **Какой способ рекомендуется использовать для статической проверки типов?**
    Обычно, для *проверки типов* в React-приложениях используется библиотека *PropTypes* (`React.PropTypes` перемещен в пакет `prop-types`, начиная с React 15.5). Для больших приложений рекомендуется использовать *статические типизаторы*, такие как Flow или TypeScript, которые выполняют проверку типов во время компиляции и предоставляют возможности по автоматическому исправлению.
    
13) #### <a name="react-advanced_13"></a> **Для чего используется пакет `react-dom`?**
    `react-dom` предоставляет *методы, специфичные для DOM*, которые могут быть использованы на верхнем уровне приложения. Большинству компонентов не нужен этот модуль. Вот некоторые из методов рассматриваемой библиотеки:
    1. `render()`
    2. `hydrate()`
    3. `unmountComponentAtNode()`
    4. `findDOMNode()`
    5. `createPortal()`
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/react-dom.html).
    
14) #### <a name="react-advanced_14"></a> **Для чего предназначен метод `render()` в `react-dom`?**
    Данный метод используется для встраивания React-элемента в DOM в определенный контейнер и возврата ссылки на этот элемент. Если React-элемент уже рендерился ранее, осуществляется обновление только той части DOM, которая подверглась изменениям.
    ```
    ReactDOM.render(element, container[, callback])
    ```
    
    При передаче опционального коллбека, он будет вызван после рендеринга или обновления.
    
15) #### <a name="react-advanced_15"></a> **Что такое `ReactDOMServer`?**
    `ReactDOMServer` - это объект, позволяющий рендерить компоненты в виде статической разметки (обычно, используется на node-серверах). Данный объект в основном используется при *рендеринге на стороне сервера*. Следующие методы могут быть использованы как на сервере, так и в браузерном окружении:
    1. `renderToString()`
    2. `renderToStaticMarkup()`

    Например, вы запускаете основанный на Node веб-сервер, такой как Express, Koa или Happi, и вызываете `renderToString()` для рендеринга корневого элемента в виде строки, которую сервер отправляет в ответ на запрос:
    ```javascript
    // используем Express
    import { renderToString } from 'react-dom/server'
    import MyPage from './MyPage'

    app.get('/', (req, res) => {
      res.write('<!DOCTYPE html><html><head><title>My Page</title></head><body>')
      res.write('<div id="content">')
      res.write(renderToString(<MyPage/>))
      res.write('</div></body></html>')
      res.end()
    })
    ```
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/react-dom-server.html).
    
16) #### <a name="react-advanced_16"></a> **Как использовать InnerHtml в React?**
    Атрибут `dangerouslySetInnerHTML` в React является альтернативой `innerHTML`. Как и последний, его использование представляет собой угрозу межсайтового скриптинга (XSS). Необходимо передать объект с ключом `__html` и HTML-разметкой в качестве значения.

    В приведенном ниже примере `MyComponent` использует атрибут `dangerouslySetInnerHTML` для определения разметки:
    ```jsx harmony
    function createMarkup() {
      return { __html: 'Первый &middot; Второй' }
    }

    function MyComponent() {
      return <div dangerouslySetInnerHTML={createMarkup()} />
    }
    ```
    
17) #### <a name="react-advanced_17"></a> **Что произойдет при использовании `setState()` в `constructor()`?**
    Если это сделать, то помимо присвоения значения объекту состояния React повторно отрендерит компонент и всех его потомков. Вы получите ошибку: *Can only update a mounted or mounting component.* (Можно обновлять только смонтированный или монтируемый компонент.) Поэтому для инициализации переменных внутри конструктора следует использовать `this.state`.
    
18) #### <a name="react-advanced_18"></a> **Почему следует избегать использования индексов в качестве ключей?**
    Ключи должны быть стабильными, предсказуемыми и уникальными, чтобы React имел возможность следить за элементами.

    В приведенном ниже примере ключом каждого элемента является порядок его расположения в массиве без привязки к предоставляемым им данным. Это ограничивает возможности React по оптимизации:
    ```jsx harmony
    {todos.map((todo, index) =>
      <Todo
        {...todo}
        key={index}
      />
    )}
    ```

    При использовании в качестве уникальных ключей данных элемента, например, `todo.id`, которые являются уникальными в списке и стабильными, у React появится возможность изменять порядок расположения элементов без необходимости выполнения дополнительных вычислений:
    ```jsx harmony
    {todos.map((todo) =>
      <Todo {...todo}
        key={todo.id} />
    )}
    ```
    
19) #### <a name="react-advanced_19"></a> **Правильно ли использовать `setState()` в методе `componentWillMount()`?**
    Да, использование `setState()` внутри `componentWillMount()` является безопасным. В то же время, рекомендуется избегать выполнения асинхронной инициализации в методе жизненного цикла `componentWillMount()`. `componentWillMount()` вызывается перед монтированием. Он также вызывается перед методом `render()`, поэтому настройка состояния в этом методе не приводит к повторному рендерингу. В нем следует избегать любых побочных эффектов и подписок. Вместо `componentWillMount()` асинхронную логику следует помещать в `componentDidMount()`.

    ```jsx harmony
    componentDidMount() {
      axios.get(`api/todos`)
        .then((result) => {
          this.setState({
            messages: [...result.data]
          })
        })
    }
    ```
    
20) #### <a name="react-advanced_20"></a> **Что произойдет при использовании пропов в начальном состоянии (Initial State)?**
    При изменении пропов компонента без его обновления, эти новые пропы никогда не будут отображены на экране, поскольку функция-конструктор никогда не обновит текущее состояние компонента. Обновление состояния через пропы возможно только после создания компонента.

    В приведенном ниже примере обновленное значение инпута никогда не отобразится:
    ```jsx harmony
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)

        this.state = {
          records: [],
          inputValue: this.props.inputValue
        };
      }

      render() {
        return <div>{this.state.inputValue}</div>
      }
    }
    ```

    Значение обновится при использовании пропов в методе `render()`:
    ```jsx harmony
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)

        this.state = {
          record: []
        }
      }

      render() {
        return <div>{this.props.inputValue}</div>
      }
    }
    ```
    
21) #### <a name="react-advanced_21"></a> **Как выполнить условный рендеринг компонентов?**
    В некоторых случаях вам нужно будет рендерить разные компоненты в зависимости от некоторого состояния. JSX не рендерит `false` или `undefined`, поэтому вы можете использовать *короткие вычисления* для рендеринга определенной части компонента только при удовлетворении условия:
    ```jsx harmony
    const MyComponent = ({ name, address }) => (
      <div>
        <h2>{name}</h2>
        {address &&
          <p>{address}</p>
        }
      </div>
    )
    ```

    Если вам требуется условие `if else`, тогда используйте *тернарный оператор*:
    ```jsx harmony
    const MyComponent = ({ name, address }) => (
      <div>
        <h2>{name}</h2>
        {address
          ? <p>{address}</p>
          : <p>{'Address is not available'}</p>
        }
      </div>
    )
    ```
    
22) #### <a name="react-advanced_22"></a> **Почему следует быть осторожным при распространении (spread) пропов на DOM-элементы?**
    При *распространении пропов* мы подвержены риску добавления неизвестных HTML-атрибутов, что считается плохой практикой. Вместо этого, лучше использовать деструктуризацию пропа с помощью оператора `...rest`. Это обеспечит добавление только нужных пропов:

    Например:
    ```jsx harmony
    const ComponentA = () =>
      <ComponentB isDisplay={true} className='someClassName' />

    const ComponentB = ({ isDisplay, ...domProps }) =>
      <div {...domProps}>{ComponentB}</div>
    ```
    
23) #### <a name="react-advanced_23"></a> **Как использовать декораторы в React?**
    Вы можете *декорировать* ваши классовые компоненты способом, аналогичным передаче компонента в функцию. *Decorators* - гибкий и удобочитаемый способ модификации функциональности компонента:
    ```jsx harmony
    @setTitle('Профиль')
    class Profile extends React.Component {
        //....
    }

    /*
      title - это строка, которая устанавливается заголовку документа
      WrappedComponent - это то, что получит наш декоратор
      при его размещении над классовым компонентом
    */
    const setTitle = (title) => (WrappedComponent) => {
      return class extends React.Component {
        componentDidMount() {
          document.title = title
        }

        render() {
          return <WrappedComponent {...this.props} />
        }
      }
    }
    ```

    **`Важно знать!`**
    Декораторы - экспериментальная технология, находящаяся на *3 стадии рассмотрения*.
    
24) #### <a name="react-advanced_24"></a> **Как запомнить или сохранить компонент?**
    Существуют библиотеки мемоизации, которые можно использовать в функциональных компонентах.

    Например, библиотека `moize` может сохранять один компонент в другом:
    ```jsx harmony
    import moize from 'moize'
    import Component from './components/Component'
    // этот модуль экспортирует немемоизированный компонент

    const MemoizedFoo = moize.react(Component)

    const Consumer = () => {
      <div>
        {/* Это сохранит следующий компонент: */}
        <MemoizedFoo />
      </div>
    }
    ```

    Начиная с React 16.6.0, у нас имеется `React.memo()`. Это компонент высшего порядка, который сохраняет компонент неизменным до обновления его пропов. Для этого достаточно обернуть в него мемоизируемый компонент перед использованием последнего:
    ```js
      const MemoComponent = React.memo(function MemoComponent(props) {
        /* рендеринг с помощью пропов */
      });
      // или
      export default React.memo(MyFunctionComponent);
    ```

    Также следует отметить, что похожий функционал предоставляет хук `useMemo()`.
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/react-api.html#reactmemo).
    
25) #### <a name="react-advanced_25"></a> **Как реализовать рендеринг на стороне сервера или SSR?**
    React поддерживает рендеринг на стороне Node-сервера из коробки. Для этого используется специальная версия DOM-рендерера, которая реализует такой же паттерн, что и клиентская версия:

    ```jsx harmony
    import ReactDOMServer from 'react-dom/server'
    import App from './App'

    ReactDOMServer.renderToString(<App />)
    ```

    Этот метод возвращает обычный HTML в виде строки, которая затем может быть помещена в тело (body) ответа сервера. На стороне клиента React определяет предварительно отрендеренный контент и просто вставляет его в существующее дерево компонентов.
    
26) #### <a name="react-advanced_26"></a> **Как включить производственный(production) режим в React?**
    Для этого следует установить `NODE_ENV` в значение `production` в методе `DefinePlugin()` Webpack. Это отключит проверку типов и дополнительные предупреждения. Кроме того, при минификации кода, например, с помощью Uglify, удаляющего "мертвый" код, а также код и комментарии для разработки, размер сборки будет намного меньше.
    
27) #### <a name="react-advanced_27"></a> **Что такое CRA(create-react-app) и в чем заключаются преимущества его использования?**
    `create-react-app` - это инструмент, позволяющий быстро создавать и запускать React-приложения, минуя стадию настройки.

    Создадим Todo App с помощью *CRA*:
    ```console
    # Создание нового проект
    $ npx create-react-app todo-app
    // или
    $ npm init react-app todo-app
    // или
    $ yarn create react-app todo-app

    $ cd todo-app

    # Сборка, тестирование и запуск
    $ npm run build
    $ npm run test
    $ npm start
    // или
    $ yarn build
    $ yarn test
    $ yarn start
    ```

    Проект включает в себя все необходимое для разработки приложения на React:
    1. Поддержка синтаксиса ES6, React, JSX и Flow.
    2. Расширения языка после ES6, такие как spread- и rest-операторы.
    3. Автоматическое добавление префиксов к стилям, поэтому вам не нужно вручную добавлять -webkit- и другие префиксы.
    4. Быстрый запуск интерактивных юнит-тестов со встроенной поддержкой отчетов о покрытии кода тестами.
    5. Автоматически перезапускаемый сервер для разработки, выводящий предупреждения о наиболее распространенных ошибках.
    6. Скрипт для сборки JS, CSS и статических файлов для продакшна с хэшами в названиях и картами ресурсов (sourcemaps).
    
28) #### <a name="react-advanced_28"></a> **Назовите методы жизненного цикла, относящиеся к монтированию**
    При создании и встраивании компонента в DOM методы жизненного цикла вызываются в следующем порядке:
    1. `constructor()`
    2. `static getDerivedStateFromProps()`
    3. `render()`
    4. `componentDidMount()`
    
29) #### <a name="react-advanced_29"></a> **Какие методы жизненного цикла были признаны устаревшими в React 16?**
    Следующие методы жизненного цикла являются небезопасными практиками кодирования и усложняют работу с асинхронной логикой:
    1. `componentWillMount()`
    2. `componentWillReceiveProps()`
    3. `componentWillUpdate()`

    Начиная с React 16.3, эти методы следует использовать с префиксом `UNSAFE_`, а версии без префиксов были удалены в React 17.
    
30) #### <a name="react-advanced_30"></a> **Для чего используется метод жизненного цикла `getDerivedStateFromProps()`?**
    Новый статический метод жизненного цикла `getDerivedStateFromProps()` вызывается после инстанцирования элемента перед его повторным рендерингом. Он может возвращать объект для обновления состояния или `null` как индикатор того, что новые пропы не требуют обновления состояния.
    ```javascript
    class MyComponent extends React.Component {
      static getDerivedStateFromProps(props, state) {
        // ...
      }
    }
    ```

    Этот метод вместе с `componentDidUpdate()` охватывает все случаи использования `componentWillReceiveProps()`.
    
31) #### <a name="react-advanced_31"></a> **Для чего используется метод жизненного цикла `getSnapshotBeforeUpdate()`?**
    Новый метод жизненного цикла `getSnapshotBeforeUpdate()` вызывается сразу после обновления DOM. Значение, возвращенное этим методом, передается в качестве третьего аргумента `componentDidUpdate()`.
    ```javascript
    class MyComponent extends React.Component {
      getSnapshotBeforeUpdate(prevProps, prevState) {
        // ...
      }
    }
    ```

    Этот метод вместе с `componentDidUpdate()` охватывает все случаи использования `componentWillUpdate()`.
    
32) #### <a name="react-advanced_32"></a> **Заменяют ли хуки рендер-пропы и компоненты высшего порядка?**
    Рендер-пропы и компоненты высшего порядка рендерят только одного потомка, однако, в большинстве случаев, хуки предоставляют более простой способ минимизировать количество уровней вложенности дерева компонентов.
    
33) #### <a name="react-advanced_33"></a> **Как рекомендуется называть компоненты?**
    Компоненты рекомендуется именовать с помощью ссылок вместо использования `displayName`.
    
    Использование `displayName`:
    ```javascript
    export default React.createClass({
      displayName: 'TodoApp',
      // ...
    })
    ```

    *Рекомендуемый* подход:
    ```javascript
    export default class TodoApp extends React.Component {
      // ...
    }
    ```
    
34) #### <a name="react-advanced_34"></a> **Какой порядок расположения методов в классовом компоненте является рекомендуемым?**
    *Рекомендуемый* порядок расположения методов от *монтирования* до *рендеринга* следующий:
    1. `static` методы
    2. `constructor()`
    3. `getChildContext()`
    4. `componentWillMount()`
    5. `componentDidMount()`
    6. `componentWillReceiveProps()`
    7. `shouldComponentUpdate()`
    8. `componentWillUpdate()`
    9. `componentDidUpdate()`
    10. `componentWillUnmount()`
    11. обработчики событий, такие как `handleSubmit()` или `handleChange()`
    12. геттеры для рендеринга, такие как `getSelectReason()` или `getFooterContent()`
    13. опциональные методы рендеринга, такие как `renderNavigation()` или `renderProfilePicture()`
    14. `render()`
    
35) #### <a name="react-advanced_35"></a> **Что такое компонент-переключатель (Switching Component)?**
    *Switching component* - это компонент, который рендерит один из нескольких компонентов. Для получения значений пропов для компонентов необходимо использовать объект.

    Например, вот компонент-переключатель, отображающий разные страницы на основе пропа `page`:
    ```jsx harmony
    import HomePage from './HomePage'
    import AboutPage from './AboutPage'
    import ServicesPage from './ServicesPage'
    import ContactPage from './ContactPage'

    const PAGES = {
      home: HomePage,
      about: AboutPage,
      services: ServicesPage,
      contact: ContactPage
    }

    const Page = (props) => {
      const Handler = PAGES[props.page] || ContactPage

      return <Handler {...props} />
    }

    // ключи объекта PAGES могут быть использованы в propTypes для перехвата ошибок в процессе разработки
    Page.propTypes = {
      page: PropTypes.oneOf(Object.keys(PAGES)).isRequired
    }
    ```
    
36) #### <a name="react-advanced_36"></a> **Для чего в `setState()` передается функция?**
    Дело в том, что `setState()` - это асинхронная операция. React откладывает обновление состояния по причинам производительности, поэтому состояние может обновиться не сразу после вызова `setState()`. Это означает, что вам не следует полагаться на текущее состояние при вызове `setState()`, поскольку вы не можете быть уверены в том, каким оно является. Решением названной проблемы является передача в `setState()` функции с предыдущим состоянием в качестве аргумента. Это позволяет избежать проблем, связанных с получением пользователем старого состояния из-за асинхронной природы `setState()`.

    Допустим, начальным значением count является 0. Несмотря на три последовательных вызова операции по увеличению значения, count равняется 1:
    ```javascript
    // предположим, что this.state.count === 0
    this.setState({ count: this.state.count + 1 })
    this.setState({ count: this.state.count + 1 })
    this.setState({ count: this.state.count + 1 })
    // this.state.count === 1, а не 3
    ```

    Если мы передадим функцию в `setState()` значение count увеличится корректно:
    ```javascript
    this.setState((prevState, props) => ({
      count: prevState.count + props.increment
    }))
    // this.state.count === 3 как ожидается
    ```

    **(или)**
    **Почему в `setState()` рекомендуется использовать функцию, а не объект?**

     React может объединять несколько вызовов `setState()` в один для повышения производительности. Поскольку `this.props` и `this.state` обновляются асинхронно, вам не следует полагаться на их значения для вычисления следующего состояния.

     Приведенный ниже пример счетчика работает неправильно:
     ```javascript
     // Неправильно
     this.setState({
       counter: this.state.counter + this.props.increment,
     })
     ```

     Рекомендуемый подход заключается в вызове `setState()` с функцией в качестве аргумента. Эта функция принимает предыдущее состояние в качестве первого параметра и обновленные пропы в качестве второго параметра:
     ```javascript
     // Correct
     this.setState((prevState, props) => ({
       counter: prevState.counter + props.increment
     }))
     ```
     
37) #### <a name="react-advanced_37"></a> **Что такое строгий режим в React?**
    `React.StrictMode` - это полезный компонент, обеспечивающий индикацию потенциальных проблем в приложении. Как и `<Fragment>`, `<StrictMode>` не приводит к рендеренгу лишних DOM-элементов. Он активирует дополнительные проверки и предупреждения для потомков. Эти проверки применяются только в *режиме для разработки*.
    ```jsx harmony
    import React from 'react'

    function ExampleApplication() {
      return (
        <div>
          <Header />
          <React.StrictMode>
            <div>
              <ComponentOne />
              <ComponentTwo />
            </div>
          </React.StrictMode>
          <Footer />
        </div>
      )
    }
    ```

    В приведенном примере *строгий режим* включен только для компонентов `ComponentOne` и `ComponentTwo`.
    
    Подробнее можно узнать в официальной [документации](https://ru.reactjs.org/docs/strict-mode.html).
    
38) #### <a name="react-advanced_38"></a> **Что такое React-примеси (Mixins)?**
    *Mixins* - это способ обеспечения совместного использования функциональности совершенно разными компонентами. Примеси *не следует использовать*, их можно заменить *компонентами высшего порядка* или *декораторами*.

    Одним из самых распространенных случаев использования примесей является `PureRenderMixin`. Вы можете использовать его в некоторых компонентах для предотвращения повторного рендеринга, когда пропы и состояние поверхностно равны предыдущим:

    ```javascript
    const PureRenderMixin = require('react-addons-pure-render-mixin')

    const Button = React.createClass({
      mixins: [PureRenderMixin],
      // ...
    })
    ```

    **`Важно знать!`**
    В настоящее время примеси признаны устаревшими.
    
39) #### <a name="react-advanced_39"></a> **Почему `isMounted()` является антипаттерном? Назовите более подходящее решение**
    Основная цель использования `isMounted()` заключается в предотвращении вызова `setState()` после размонтирования компонента, поскольку это приводит к выводу в консоль предупреждения.
    ```javascript
    if (this.isMounted()) {
      this.setState({...})
    }
    ```

    Проверка `isMounted()` перед вызовом `setState()` отключает предупреждения, но противоречит цели этих предупреждений. Использование `isMounted()` - это *дурно пахнущий* код, поскольку единственная причина его использования заключается в предположении, что вам потребуется ссылка на компонент после его размонтирования.

    Оптимальным решением является определение места, где `setState()` может быть вызван после размонтирования компонента, и его удаление. Такие ситуации обычно возникают в коллбеках, когда компонент ожидает получения некоторых данных и размонтируется до их получения. В идеале, все коллбеки должны отключаться в `componentWillUnmount()` перед размонтированием.
    
40) #### <a name="react-advanced_40"></a> **Какие события указателя (Pointer Events) поддерживаются в React?**
    *Pointer Events* предоставляют унифицированный способ обработки всех событий ввода. Раньше у нас была мышь и соответствующие обработчики, сегодня у нас имеется множество различных устройств, в состав которых мышь не входит, например, телефоны с событиями касаний экрана пальцем или стилусом. Необходимо помнить, что эти события работают только в браузерах, поддерживающих *Pointer Events*.

    Следующие типы событий недоступны в *React DOM*:
    1. `onPointerDown`
    2. `onPointerMove`
    3. `onPointerUp`
    4. `onPointerCancel`
    5. `onGotPointerCapture`
    6. `onLostPointerCapture`
    7. `onPointerEnter`
    8. `onPointerLeave`
    9. `onPointerOver`
    10. `onPointerOut`
    
41) #### <a name="react-advanced_41"></a> **Почему название компонента должно начинаться с большой буквы?**
    Если вы рендерите компонент с помощью JSX, название этого компонента должно начинаться с большой буквы, в противном случае, React выбросит исключение, связанное с неопознанным тегом. Принятое соглашение гласит, что с маленькой буквы могут начинаться только HTML и SVG-теги.
    ```jsx harmony
    class SomeComponent extends Component {
     // ...
    }
    ```

    Вы можете определить классовый компонент, название которого начинается с маленькой буквы, но при импорте название должно начинаться с большой буквы. Здесь название, начинающееся с маленькой буквы, не вызовет проблем:
    ```jsx harmony
    class myComponent extends Component {
      render() {
        return <div />
      }
    }

    export default myComponent
    ```

    При импорте указанного компонента в другой файл, его название должно начинаться с большой буквы:
    ```jsx harmony
    import MyComponent from './MyComponent'
    ```

    **Существуют ли исключения из этого правила?**
     Названия компонентов должны начинаться с большой буквы, за одним исключением. Имена тегов, начинающиеся с маленькой буквы, с точкой (аксессоры) являются валидными названиями компонентов.

     Например, следующий тег будет скомпилирован в валидный компонент:

     ```javascript
     render(){
        return (
            <obj.component /> // `React.createElement(obj.component)`
        )
     }
     ```
     
42) #### <a name="react-advanced_42"></a> **Поддерживаются ли пользовательские DOM-атрибуты в React 16?**
    Да. В прошлом React игнорировал неизвестные атрибуты. Если вы использовали атрибут, который React не мог распознать, он просто его пропускал:

    Например, элемент с таким атрибутом:
    ```jsx harmony
    <div mycustomattribute={'something'} />
    ```

    в React 15 превращался в пустой `div`:
    ```html
    <div />
    ```

    В React 16 любые неизвестные атрибуты встраиваются в DOM:
    ```html
    <div mycustomattribute='something' />
    ```

    Это полезно с точки зрения использования специфичных для браузера атрибутов, тестирования новых DOM API и интеграции с другими библиотеками.
    
43) #### <a name="react-advanced_43"></a> **В чем разница между `constructor()` и `getInitialState()`?**
    При использовании ES6-классов состояние следует инициализировать в конструкторе, а при использовании `React.createClass()` - в методе `getInitialState()`.

    **ES6-классы:**
    ```javascript
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)
        this.state = { /* начальное состояние */ }
      }
    }
    ```

    **React.createClass():**
    ```javascript
    const MyComponent = React.createClass({
      getInitialState() {
        return { /* начальное состояние */ }
      }
    })
    ```

    **`Важно знать!`**
    `React.createClass()` признан устаревшим и удален в React 16. Для создания компонентов с состоянием используйте классы или функции с хуками.
    
44) #### <a name="react-advanced_44"></a> **Можно ли принудительно обновить компонент без вызова `setState()`?**
    По умолчанию компонент перерисовывается при изменении его состояния или пропов. Если метод `render()` зависит от других данных, вы можете сообщить React о том, что компонент нуждается в повторном рендеринге, вызвав `forceUpdate()`.
    ```javascript
    component.forceUpdate(callback)
    ```

    **`Важно знать!`**
    Использовать `forceUpdate()` не рекомендуется.
    
45) #### <a name="react-advanced_45"></a> **В чем разница между `super()` и `super(props)` в классовых компонентах React?**
    Если вы хотите получить доступ к `this.props` в `constructor()`, тогда пропы должны быть переданы в метод `super()`.

    **super(props):**
    ```javascript
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)
        console.log(this.props) // { name: 'John', ... }
      }
    }
    ```

    **super():**
    ```javascript
    class MyComponent extends React.Component {
      constructor(props) {
        super()
        console.log(this.props) // undefined
      }
    }
    ```

    За пределами `constructor()`, `this.props` имеет одинаковое значение.
    
46) #### <a name="react-advanced_46"></a> **Как реализовать цикл внутри JSX?**
    Для этого можно использовать `Array.prototype.map()` и стрелочную функцию.

    Например, в следующем примере массив объектов `items` преобразуется в массив компонентов:
    ```jsx harmony
    <tbody>
      {items.map(item => <SomeComponent key={item.id} name={item.name} />)}
    </tbody>
    ```

    Однако, с помощью `for` реализовать цикл не получится:
    ```jsx harmony
    <tbody>
      for (let i = 0; i < items.length; i++) {
        <SomeComponent key={items[i].id} name={items[i].name} />
      }
    </tbody>
    ```

    Это объясняется тем, что JSX-теги транспилируются в *вызовы функций*, а мы не можем использовать операторы внутри выражений. Ситуация может измениться благодаря выражению `do`, которое находится на *1 стадии рассмотрения*.
    
47) #### <a name="react-advanced_47"></a> **Как получить доступ к пропам в закавыченных значениях атрибутов?**
    React (или JSX) не поддерживает интерполяцию переменных в значениях атрибутов. Следующий код не будет работать:
    ```jsx harmony
    <img className='image' src='images/{this.props.image}' />
    ```

    Однако, вы можете поместить любое JavaScript-выражение в фигурные скобки как входящее значение атрибута. Следующий код работает, как ожидается:
    ```jsx harmony
    <img className='image' src={'images/' + this.props.image} />
    ```

    Также можно использовать *шаблонные литералы* (template literals):
    ```jsx harmony
    <img className='image' src={`images/${this.props.image}`} />
    ```
    
48) #### <a name="react-advanced_48"></a> **Что такое массив React PropType с формой (shape)?**
    Если вы хотите передать массив объектов в компонент с определенной формой, тогда используйте `React.PropTypes.shape()` в качестве аргумента `React.PropTypes.arrayOf()`:
    ```javascript
    ReactComponent.propTypes = {
      arrayWithShape: React.PropTypes.arrayOf(React.PropTypes.shape({
        color: React.PropTypes.string.isRequired,
        fontSize: React.PropTypes.number.isRequired
      })).isRequired
    }
    ```
    
49) #### <a name="react-advanced_49"></a> **Как реализовать условное применение классовых атрибутов?**
    Вам не следует использовать фигурные скобки внутри кавычек, поскольку в этом случае они будут оцениваться как строка:
    ```jsx harmony
    <div className="btn-panel {this.props.visible ? 'show' : 'hidden'}">
    ```

    Вместо этого, фигурные скобки следует поместить снаружи (не забудьте добавить пробел между названиями классов):
    ```jsx harmony
    <div className={'btn-panel ' + (this.props.visible ? 'show' : 'hidden')}>
    ```

    Либо используйте *шаблонные строки*:
    ```jsx harmony
    <div className={`btn-panel ${this.props.visible ? 'show' : 'hidden'}`}>
    ```
    
50) #### <a name="react-advanced_50"></a> **В чем разница между React и ReactDOM?**
    Пакет `react` содержит `React.createElement()`, `React.Component`, `React.Children` и другие вспомогательные функции, связанные с элементами и компонентами. Вы можете думать о них как об изоморфных или универсальных помощниках в создании компонентов. Пакет `react-dom` содержит `ReactDOM.render()`, а в `react-dom/server` у нас имеется *рендеринг на стороне сервера*, обеспечиваемый такими методами как `ReactDOMServer.renderToString()` и `ReactDOMServer.renderToStaticMarkup()`.
    
51) #### <a name="react-advanced_51"></a> **Почему ReactDOM отделен от React?**
    Команда React проделала большую работу по извлечению всех "фич", связанных с DOM, в отдельную библиотеку под названием *ReactDOM*. Впервые библиотеки были разделены в React 0.14. Учитывая другие библиотеки, такие как `react-native`, `react-art`, `react-canvas` и `react-three`, становится очевидным, что React не должен быть тесно связан с браузером или DOM.

    Для обеспечения рендеринга в разных средах, команда React разделила основной пакет React на две части: `react` и `react-dom`. Это позволяет создавать компоненты, которые могут использоваться как в веб, так и в мобильной версиях приложения.
    
52) #### <a name="react-advanced_52"></a> **Как использовать элемент `label` в React?**
    Если вы попытаетесь отрендерить элемент `label`, привязав его к инпуту с помощью стандартного атрибута `for`, то в готовой разметке этот атрибут будет пропущен, а в консоль будет выведено предупреждение:
    ```jsx harmony
    <label for='user'>Пользователь</label>
    <input type='text' id='user' />
    ```

    Поскольку `for` в JavaScript является ключевым словом, вместо него следует использовать `htmlFor`:
    ```jsx harmony
    <label htmlFor='user'>Пользователь</label>
    <input type='text' id='user' />
    ```
    
53) #### <a name="react-advanced_53"></a> **Как совместно использовать несколько встроенных объектов со стилями?**
    Для этого можно использовать *spread-оператор* в обычном React:
    ```jsx harmony
     <button style={{...styles.panel.button, ...styles.panel.submitButton}}>Отправить</button>
    ```

    В React Native можно использовать синтаксис массивов:
    ```jsx harmony
    <button style={[styles.panel.button, styles.panel.submitButton]}>Отправить</button>
    ```
    
54) #### <a name="react-advanced_54"></a> **Как повторно отрендерить слой представления при изменении размеров браузера?**
     Для этого можно прослушивать событие `resize` в методе `componentDidMount()` и обновлять направления (`width` и `height`). Не забудьте удалить обработчик в методе `componentWillUnmount()`.
     ```javascript
     class WindowDimensions extends React.Component {
       constructor(props){
         super(props);
         this.updateDimensions = this.updateDimensions.bind(this);
       }

       componentWillMount() {
         this.updateDimensions()
       }

       componentDidMount() {
         window.addEventListener('resize', this.updateDimensions)
       }

       componentWillUnmount() {
         window.removeEventListener('resize', this.updateDimensions)
       }

       updateDimensions() {
         this.setState({width: window.innerWidth, height: window.innerHeight})
       }

       render() {
         return <span>{this.state.width} x {this.state.height}</span>
       }
     }
     ```

    Вот аналогичный функциональный компонент:
    ```javascript
    function WindowDimensions() {
      const [state, setState] = useState({
        width: window.innerWidth,
        height: window.innerHeight
      })

      function updateDimensions() {
        setState({
          width: window.innerWidth,
          height: window.innerHeight
        })
      }

      useEffect(() => {
        window.addEventListener('resize', updateDimensions)
        return () => {
          window.removeEventListener('resize', updateDimensions)
        }
      }, [])

      return <span>{state.width} x {state.height}</span>
    }
    ```
    
55) #### <a name="react-advanced_55"></a> **В чем разница между методами `setState()` и `replaceState()`?**
    При использовании `setState()` текущее и предыдущее состояния объединяются. `replaceState()` удаляет текущее состояние и заменяет его переданным. Обычно, `setState()` используется до тех пор, пока вам действительно не понадобится удалить все предыдущие ключи по какой-то причине. Вы также можете установить состояние в значение `false`/`null` в `setState()` вместо использования `replaceState()`.
     
56) #### <a name="react-advanced_56"></a> **Как следить за изменением состояния компонента?**
    При обновлении состояния вызывается метод жизненного цикла `componentDidUpdate()`. Вы можете сравнить передаваемое состояние и пропы с предыдущими для выявления изменений.
    ```
    componentDidUpdate(object prevProps, object prevState)
    ```

    **`Важно знать!`**
    В предыдущих версиях React для обновления состояния можно было использовать `componentWillUpdate(object nextProps, object nextState)`. Впоследствии, данный метод был признан устаревшим.
    
57) #### <a name="react-advanced_57"></a> **Как рекомендуется удалять элемент из массива в состоянии React?**
    Оптимальный подход заключается в использовании метода `Array.prototype.filter()`.

    Создадим метод `removeItem()` для обновления состояния:
    ```javascript
    removeItem(index) {
      this.setState({
        data: this.state.data.filter((item, i) => i !== index)
      })
    }
    ```
    
58) #### <a name="react-advanced_58"></a> **Возможно ли использовать React без рендеринга HTML?**
    В новых версиях (>=16.2) это вполне возможно. Ниже представлено несколько вариантов:
    ```jsx harmony
    render() {
      return false
    }
    ```
    
    ```jsx harmony
    render() {
      return null
    }
    ```
    
    ```jsx harmony
    render() {
      return []
    }
    ```
    
    ```jsx harmony
    render() {
      return <React.Fragment></React.Fragment>
    }
    ```
    
    ```jsx harmony
    render() {
      return <></>
    }
    ```
    
    С `undefined` это не работает.
    
59) #### <a name="react-advanced_59"></a> **Как красиво отобразить JSON с помощью React?**
    Мы можем использовать тег `pre` для сохранения форматирования, произведенного `JSON.stringify()`:
    ```jsx harmony
    const data = { name: 'Иван', age: 42 }
    
    class User extends React.Component {
      render() {
        return (
          <pre>
            {JSON.stringify(data, null, 2)}
          </pre>
        )
      }
    }
    
    React.render(<User />, document.getElementById('container'))
    ```
    
60) #### <a name="react-advanced_60"></a> **Почему в React нельзя обновлять пропы?**
    Философия React гласит, что пропы должны быть *иммутабельными* (неизменяемыми или неизменными) и *однонаправленными* (передаваемыми в одном направлении, сверху вниз). Это означает, что родительский компонент может передавать пропы дочерним, а последние не могут их модифицировать.
    
61) #### <a name="react-advanced_61"></a> **Как установить фокус на инпут при загрузке страницы?**
    Это можно сделать, создав *ссылку* (ref) на элемент `input`, и использовав метод `componentDidMount()`:
    ```jsx harmony
    class App extends React.Component{
      componentDidMount() {
        this.nameInput.focus()
      }

      render() {
        return (
          <div>
            <input
              defaultValue='Не в фокусе'
            />
            <input
              ref={(input) => this.nameInput = input}
              defaultValue='В фокусе'
            />
          </div>
        )
      }
    }

    ReactDOM.render(<App />, document.getElementById('app'))
    ```
    
62) #### <a name="react-advanced_62"></a> **Какие существуют способы обновления объекта состояния?**
    1. **Вызов `setState()` с объектом, объединяемым с состоянием:**
        - Использование `Object.assign()` для создания копии объекта:
            ```javascript
            const user = Object.assign({}, this.state.user, { age: 42 })
            this.setState({ user })
            ```

        - Использование *spread-оператора*:
            ```javascript
            const user = { ...this.state.user, age: 42 }
            this.setState({ user })
            ```

    2. **Вызов `setState()` с функцией:**
        ```javascript
        this.setState(prevState => ({
          user: {
            ...prevState.user,
            age: 42
          }
        }))
        ```

    3. **Вызов сеттера, возвращенного `useState()`:**
        ```javascript
        const [user, setUser] = useState({name: 'Иван'})
        setUser({...user, age: 42})
        ```
        
63) #### <a name="react-advanced_63"></a> **Как получить версию React при запуске приложения в браузере?**
    Для этого можно использовать `React.version`:
    ```jsx harmony
    const REACT_VERSION = React.version

    ReactDOM.render(
      <div>{`Версия React: ${REACT_VERSION}`}</div>,
      document.getElementById('app')
    )
    ```
    
64) #### <a name="react-advanced_64"></a> **Какие существуют подходы к добавлению полифилов в `create-react-app`?**
    1. **Импорт из `core-js` вручную:**
        Создаем файл, например, `polyfills.js` и импортируем его в корневой файл `index.js`. Выполняем `npm install core-js` или `yarn add core-js` и импортируем необходимый функционал:
        ```javascript
        import 'core-js/fn/array/find'
        import 'core-js/fn/array/includes'
        import 'core-js/fn/number/is-nan'
        ```

    2. **Использование специального сервиса:**
        Извлекаем из *polyfill.io* CDN определенные, специфичные для браузера полифилы посредством добавления такой строки в `index.html`:
        ```html
        <script src='https://cdn.polyfill.io/v2/polyfill.min.js?features=default,Array.prototype.includes'></script>
        ```

        В примере мы дополнительно запрашиваем `Array.prototype.includes()`, поскольку он не включен в стандартный набор.
        
65) #### <a name="react-advanced_65"></a> **Как использовать https вместо http в `create-react-app`?**
    Для этого нужно использовать опцию `HTTPS=true`. Вы можете отредактировать раздел со скриптами в `package.json` следующим образом:
    ```json
    "scripts": {
      "start": "set HTTPS=true && react-scripts start"
    }
    ```

    Или просто выполнить команду `set HTTPS=true && npm start`.
    
66) #### <a name="react-advanced_66"></a> **Как избежать использования относительных путей при импорте в `create-react-app`?**
    Создайте файл `.env` в корневой директории проекта и добавьте в него адрес импорта:
    ```
    NODE_PATH=src/app
    ```

    Затем перезагрузите сервер для разработки. После этого у вас появится возможность импортировать все, что находится в `src/app`, без использования относительных путей.

    Вы также можете создать в корневой директории проекта файл `jsconfig.json` следующего содержания:
    ```
    {
      "compilerOptions": {
        "baseUrl": "src"
      },
      "include": [
        "src"
      ]
    }
    ```

    В последнем случае импорт файлов будет начинаться с src:
    ```javascript
    // вместо '../app', например
    import Component from 'app/Component.js'
    ```
    
67) #### <a name="react-advanced_67"></a> **Как добавить Google Analytics в React Router?**
    Добавьте обработчик к объекту `history` для записи каждого отображения страницы:
    ```javascript
    history.listen(function (location) {
      window.ga('set', 'page', location.pathname + location.search)
      window.ga('send', 'pageview', location.pathname + location.search)
    })
    ```
    
68) #### <a name="react-advanced_68"></a> **Как обновлять состояние компонента каждую секунду?**
    Для этого нужно использовать `setInterval()`, изменяющий состояние. Не забудьте отключить таймер при размонтировании омпонента во избежание ошибок и утечек памяти:
    ```javascript
    componentDidMount() {
      this.interval = setInterval(() => this.setState({ time: Date.now() }), 1000)
    }

    componentWillUnmount() {
      clearInterval(this.interval)
    }
    ```

    Аналогичный функциональный компонент:
    ```javascript
    const [time, setTime] = useState(Date.now)

    useEffect(() => {
      const timerId = setInterval(() => setTime(Date.now), 1000)
      return () => {
        clearInterval(timerId)
      }
    }, [time])
    ```
    
69) #### <a name="react-advanced_69"></a> **Как применить вендорные префиксы во встроенных стилях в React?**
    React не применяет *вендорные префиксы* автоматически. Вам необходимо добавлять их вручную:
    ```jsx harmony
    <div style={{
      transform: 'rotate(90deg)',
      WebkitTransform: 'rotate(90deg)', // обратите внимание на большую букву "W"
      msTransform: 'rotate(90deg)' // 'ms' - это единственный вендорный префикс в нижнем регистре
    }} />
    ```

    Такие библиотеки, как `styled-components` добавляют префиксы автоматически.
    
70) #### <a name="react-advanced_70"></a> **Как экспортировать/импортировать компоненты с помощью React и ES6?**
    Для экспорта компонентов рекомендуется использовать экспорт по умолчанию:
    ```jsx harmony
    import React from 'react'
    import User from 'user'

    export default class MyProfile extends React.Component {
      render(){
        return (
          <User type="customer">
            //...
          </User>
        )
      }
    }
    ```

    Вспомогательные элементы могут экспортироваться по названию.
    
    **`Важно знать!`**
    При агрегации экспортируемых компонентов в файле `index.js`, удобнее использовать именованный экспорт, в противном случае, придется делать так:

    ```javascript
     export { default as Component } from './Component'
    ```
    
71) #### <a name="react-advanced_71"></a> **Почему конструктор компонента вызывается только один раз?**
    Алгоритм *согласования* без дополнительной информации предполагает, что если определенный компонент находится на том же месте при последующем рендеринге, то это тот же самый компонент, что и раньше, поэтому используется предыдущий экземпляр вместо создания нового.
    
72) #### <a name="react-advanced_72"></a> **Как в React определяются константы?**
    Для определения константы можно использовать синтаксис *статических полей класса*:
    ```javascript
    class MyComponent extends React.Component {
      static DEFAULT_PAGINATION = 10
    }
    ```

    **`Важно знать!`**
    Данное предложение находится на *3 стадии рассмотрения*.
    
73) #### <a name="react-advanced_73"></a> **Как программно вызвать возникновение события клика в React?**
    Вы можете использовать проп `ref` через коллбек в качестве ссылки на `HTMLInputElement`,  сохранить эту ссылку в свойстве класса и использовать ее для вызова события в обработчике с помощью метода `click()`.

    Это делается в два этапа:
    1. Создаем ссылку в методе `render()`:
        ```jsx harmony
        <input ref={input => this.inputElement = input} />
        ```

    2. Вызываем событие клика в обработчике:
        ```javascript
        this.inputElement.click()
        ```

    Тоже самое можно реализовать с помощью хука `useRef()`.
    
74) #### <a name="react-advanced_74"></a> **Можно ли использовать `async/await` в обычном React?**
    Новые версии React поддерживают синтаксис `async/await` из коробки.
    Раньше для этого надо было использовать *Babel* и плагин [transform-async-to-generator](https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator).
    
75) #### <a name="react-advanced_75"></a> **Назовите общую структуру директорий в React-проекте**
    Существует два варианта структурирования файлов проекта на React:
    1. **Группировка по "фичам" или маршрутам:**
        ```
        common/
        ├─ Avatar.js
        ├─ Avatar.css
        ├─ APIUtils.js
        └─ APIUtils.test.js
        feed/
        ├─ index.js
        ├─ Feed.js
        ├─ Feed.css
        ├─ FeedStory.js
        ├─ FeedStory.test.js
         ─ FeedAPI.js
        profile/
        ├─ index.js
        ├─ Profile.js
        ├─ ProfileHeader.js
        ├─ ProfileHeader.css
        └─ ProfileAPI.js
        ```

    2. **Группировка по типам файлов:**
        ```
        api/
        ├─ APIUtils.js
        ├─ APIUtils.test.js
        ├─ ProfileAPI.js
        └─ UserAPI.js
        components/
        ├─ Avatar.js
        ├─ Avatar.css
         ─ Feed.js
        ├─ Feed.css
        ├─ FeedStory.js
        ├─ FeedStory.test.js
        ├─ Profile.js
        ├─ ProfileHeader.js
        └─ ProfileHeader.css
        ```
        
76) #### <a name="react-advanced_76"></a> **Назовите популярные библиотеки для работы с анимацией в React**
    *React Transition Group* и *React Motion* являются самыми популярными библиотеками для работы с анимацией в экосистеме React.
    
77) #### <a name="react-advanced_77"></a> **В чем заключаются преимущества использования модулей со стилями?**
    Рекомендуется избегать жесткого кодирования стилей в компонентах. Любые значения, которые предполагается использовать в нескольких компонентах, должны быть извлечены в собственные модули.

    Например, эти стили могут быть извлечены в разные компоненты:
    ```javascript
    export const colors = {
      white,
      black,
      blue
    }

    export const space = [
      0,
      8,
      16,
      32,
      64
    ]
    ```

    И затем импортироваться в компоненты по необходимости:

    ```javascript
    import { space, colors } from './styles'
    ```
    
78) #### <a name="react-advanced_78"></a> **Назовите популярные линтеры для React**
    Самым популярным линтером для JavaScript является ESLint. Для анализа специфического кода доступны специальные плагины. Одним из наиболее распространенных в случае с React является пакет `eslint-plugin-react`. По умолчанию он следует набору лучших практик, включая правила определения наличия ключей в циклах и полный набор типов пропов.

    Другим популярным инструментом является `eslint-plugin-jsx-a11y`, который помогает исправлять распространенные проблемы с доступностью. Поскольку JSX отличается от обычного HTML, проблемы с текстом `alt` или `tabindex`, например, не будут обнаруживаться обычными плагинами.
    
79) #### <a name="react-advanced_79"></a> **Как выполнить AJAX-запрос и в каком методе жизненного цикла это следует делать?**
    Для этого можно использовать такие библиотеки, как jQuery AJAX, Axios или встроенный `fetch`. Вы должны запрашивать данные в методе `componentDidMount()`. Далее для обновления компонента (при получении данных) используется `setState()`.

    В следующем примере список сотрудников запрашивается из API и записывается в локальное состояние:
    ```jsx harmony
    class MyComponent extends React.Component {
      constructor(props) {
        super(props)
        this.state = {
          employees: [],
          error: null
        }
      }

      componentDidMount() {
        fetch('https://api.example.com/items')
          .then(res => res.json())
          .then(
            (result) => {
              this.setState({
                employees: result.employees
              })
            },
            (error) => {
              this.setState({ error })
            }
          )
      }

      render() {
        const { error, employees } = this.state
        if (error) {
          return <div>Error: {error.message}</div>;
        } else {
          return (
            <ul>
              {employees.map(employee => (
                <li key={employee.name}>
                  {employee.name}-{employee.experience}
                </li>
              ))}
            </ul>
          )
        }
      }
    }
    ```

    Тоже самое можно реализовать с помощью хука `useEffect()` и сеттера, возвращённого хуком `useState()`.
    
80) #### <a name="react-advanced_80"></a> **Что такое рендер-пропы (Render Props)?**
    **Render Props** - это техника распределения кода между компонентами с помощью пропа, чьим значением является функция. Следующий компонент использует рендер-проп, возвращающий React-элемент:
    ```jsx harmony
    <DataProvider render={data => (
      <h1>{`Привет, ${data.target}`}</h1>
    )}/>
    ```

    Этот паттерн широко используется такими библиотеками, как *React Router* и *DownShift*.
***

## **Redux**
### **Общие понятия**
1) #### <a name="redux-terms_1"></a> **Состояние (State)**
    ```
    type State = any;
    ```
    *Состояние* (State) (также дерево состояния) — широкое понятие, но в Redux API это, как правило, отсылка к единственному состоянию, которое управляется стором (store) и возвращается `getState()`. Оно представляет собой все состояние Redux-приложения, которое обычно является объектом с глубокой вложенностью.

    Как правило, состояние верхнего уровня — это объект или какая-то другая коллекция вида ключ-значение, например Map, но технически это может быть любой тип. Вместе с тем, вам нужно стараться поддерживать состояние сериализуемым. Не кладите внутрь ничего, что потом не сможете легко превратить в JSON.

2) #### <a name="redux-terms_2"></a> **Экшен (Action)**
    ```
    type Action = Object
    ```
    *Экшен* — это простой объект, который представляет намерение изменить состояние. Экшены — единственный путь получить данные в сторе. Любые данные, будь то события UI, коллбэки сетевых запросов или любые другие ресурсы как веб-сокеты, должны быть в итоге обработаны, как экшены.

    Экшены обязаны иметь поле `type`, которое указывает тип производимого экшена. Типы также могут быть определены как константы и импортированы из другого модуля. Лучше использовать строки для `type`, чем [Символы](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol), потому что строки сериализуемы.

    Вся остальная структура, кроме `type`, полностью на ваше усмотрение. Если вы заинтересованы, посмотрите [Flux Standard Action](https://github.com/acdlite/flux-standard-action) для рекомендаций как нужно создавать экшен.

3) #### <a name="redux-terms_3"></a> **Редюсер (Reducer)**
    ```jsx harmony
    type Reducer<S, A> = (state: S, action: A) => S
    ```
    *Редюсер* (так же называемая, как *функция-редюсер*) — это функция, которая принимает аккумулятор и значение и возвращает новый аккумулятор. Они используются для редуцирования (сокращения) коллекции значений в единственное значение.

    Редюсеры не уникальны для Redux — они являются фундаментальным понятием в функциональном программировании. Даже большинство нефункциональных языков, как JavaScript, имеют встроенное API для редуцирования. В JavaScript это [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce).

    В Redux, аккумулирумое значение — это объект состояния, а значения, которые должны быть аккумулированы — это экшены. Редюсеры расчитывают новое состояние, учитывая предыдущее состояние и экшен (action). Они обязаны быть *чистыми функциями* — функциями, которые возвращают одинаковый результат для переданных входных данных. Они также не должны иметь побочных эффектов (side-effects). Это то, что обеспечивает интересные возможности, такие как "горячая перезагрузка" (hot reloading) и путешествия во времени (time travel).

    Редюсеры являются наиболее важным понятием в Redux.

    *Не размещайте вызовы API в редюсерах*.

4) #### <a name="redux-terms_4"></a> **Функция-диспетчер (Dispatching Function)**
    ```jsx harmony
    type BaseDispatch = (a: Action) => Action
    type Dispatch = (a: Action | AsyncAction) => any
    ```
    *Функция-диспетчер* - это функция, которая принимает экшен или асинхронный экшен и далее может или не может отправить один или несколько экшенов в стор.

    Мы должны различать функцию-диспетчер в целом и базовую функцию `dispatch`, предоставляемую экземпляром стора без всяких мидлваров (middlewares).

    Базовая функция `dispatch` *всегда* синхронно отправляет экшен в редюсер вместе с предыдущим состоянием, возвращенным из стора, для вычисления нового состояния. Оно ожидает экшен в виде простых объектов, готовых для использования в редюсере.

    Мидлвар оборачивает базовую функцию `dispatch`. Это позволяет функции-диспетчеру обрабатывать асинхронные экшены в дополнение к обычным экшенам. Мидлвар может преобразовывать, задерживать, игнорировать или иным образом интерпретировать экшены или асинхронные экшены перед передачей их к следующему мидлвару. См. ниже для получения дополнительной информации.

5) #### <a name="redux-terms_5"></a> **Генератор экшена (Action Creator)**
    ```jsx harmony
    type ActionCreator = (...args: any) => Action | AsyncAction
    ```
    *Генератор экшена* - это, совершенно очевидно, функция, которая создает экшен (action). Не следует путать эти два термина - еще раз, экшен - это структура данных, а генератор экшена - это фабрика, которая создает экшен (action).

    Вызов генератора экшена только создает экшен, но не выполняет его. Вам нужно вызвать функцию стора `dispatch` которая на самом деле вызывает изменения. Иногда мы говорим *связанные генераторы экшенов* имея ввиду функции, которые вызывают генератор экшена и сразу же отправляют его результат соответствующей части стора.

    Если генератору экшена надо получить текущее состояние, выполнить вызов API или вызвать побочный эффект, как переход маршрутизации, это должно быть возвращено асихронным экшеном (async action) вместо обычного экшена.

6) #### <a name="redux-terms_6"></a> **Асинхронный экшен (Async Action)**
    ```
    type AsyncAction = any
    ```
    *Асинхронный экшен* (async action) - это значение, которое передается в вызывающую функцию (dispatching function), но пока не готово для редюсера. Оно будет преобразовано при помощи мидлвара в экшен или набор экшенов перед отправкой в базовую функцию `dispatch()`. Асинхронные экшены могут иметь различные типы в зависимости от используемых мидлваров. Они часто являются асихронными примитивами, как промисы (Promise) или thunk, которые не передаются в редюсер немедленно, а выполняют экшен, только когда операция завершена.

7) #### <a name="redux-terms_7"></a> **Мидлвар (Middleware)**
    ```jsx harmony
    type MiddlewareAPI = { dispatch: Dispatch, getState: () => State }
    type Middleware = (api: MiddlewareAPI) => (next: Dispatch) => Dispatch
    ```
    *Мидлвар* — это функция высшего порядка, которая создает функцию-диспетчер (dispatch function), возвращающую новую функцию-диспетчер. Она часто возвращает асинхронный экшен в экшен.

    Мидлвары компонуемы с помощью функции композиции - это полезно для регистрации экшенов, выполнения побочных действий (side effects), таких как, маршрутизация или превращения асинхронного вызова API в серию синхронных экшенов.

8) #### <a name="redux-terms_8"></a> **Стор (Store)**
    ```jsx harmony
    type Store = {
      dispatch: Dispatch
      getState: () => State
      subscribe: (listener: () => void) => () => void
      replaceReducer: (reducer: Reducer) => void
    }
    ```
    *Стор* — это объект, который хранит дерево состояний приложения. В приложении должно быть только один стор, так построение происходит на уровне преобразователя (reducer).

    - `dispatch(action)` базовая функция отправки (dispatch), описанная выше.
    - `getState()` возвращает текущее состояние стора.
    - `subscribe(listener)` регистрирует функцию, которая будет вызвана при изменении состояния.
    - `replaceReducer(nextReducer)` может быть использован для реализации горячей перезагрузки (hot reload) и разделения кода. Скорее всего Вы не будете использовать ee.

9) #### <a name="redux-terms_9"></a> **Генератор стора (Store creator)**
    ```jsx harmony
    type StoreCreator = (reducer: Reducer, initialState: ?State) => Store
    ```
    *Генератор стора* — это функция, которая создает Redux-стор. Как и в случае с отправляющей функцией, мы должны различать базовый генератор стора, createStore(reducer, initialState) экспортирумый из Redux, от генератора стора, возвращаемого из расширителей стора (store enhancers).

10) #### <a name="redux-terms_10"></a> **Расширитель стора (Store enhancer)**
    ```jsx harmony
    type StoreEnhancer = (next: StoreCreator) => StoreCreator
    ```
    *Расширитель стора* — это функция высшего порядка, которая создает генератор стора, возвращающий новый, расширенный генератор стора. Это похоже на мидлвар тем, что позволяет вам изменять интерфейс в композиционном стиле.

    Расширители стора аналогичны понятию - "компоненты высшего порядка" в React, которые также иногда называются "усилителями компонент".

    Поскольку стора является не инстансом, а скорее объектом-коллекцией функций, то копии могут быть запросто созданы и модифицированы, без изменения оригинального стора. Пример в описании [compose](https://reactdev.ru/libs/redux/api/compose/) демонстрирует это.

    Скорее всего, вы никогда не будете писать расширитель стора, но вы можете использовать один предоставленный [developer tools](https://github.com/gaearon/redux-devtools). Это то, что делает "путешествие во времени" (time travel) возможным без информирования приложения, о том, что происходит. Занятно, что реализация Redux мидлваров сама по себе является расширителем стора.


### **Простые, общие вопросы**
1) #### <a name="redux-simple_1"></a> **Что такое Flux?**
    *Flux* - это *парадигма проектирования приложений*, являющаяся альтернативой более традиционному паттерну MVC. Это не фреймворк или библиотека, а новый вид архитектуры, разработанный специально для React с учетом концепции однонаправленного потока данных. Facebook использует данный паттерн в своих внутренних проектах.

    Визуальное представление рабочего процесса можно посмотреть [тут](github.com/TanikoM/React-Questions#149).

2) #### <a name="redux-simple_2"></a> **Что такое Redux?**
    *Redux* - это стабильный (предсказуемый) контейнер для хранения состояния JavaScript-приложений, основанный на паттерне проектирования *Flux*. Redux может использоваться с React и любой другой библиотекой. Он легкий (около 2 Кб) и не имеет зависимостей.

    Подробнее можно узнать из документации: [English](https://redux.js.org/introduction/getting-started), [Russian](https://rajdee.gitbooks.io/redux-in-russian/content/).

3) #### <a name="redux-simple_3"></a> **Назовите ключевые принципы Redux**
    Redux следует трем фундаментальным принципам:
      1. **Единственный источник истины:** состояние всего приложения хранится в древовидном объекта - в одном хранилище. Единственное состояние-дерево облегчает наблюдение за изменениями и отладку или инспектирование приложения.
      2. **Состояние доступно только для чтения:** единственный способ изменить состояние заключается в запуске операции - объекте, описывающем произошедшее. Это позволяет гарантировать, что ни представления, ни сетевые коллбеки не буду иметь возможности изменять состояние напрямую.
      3. **Изменения производятся с помощью "чистых" функций:** для определения того, как изменяется состояние в зависимости от операции, создаются редукторы (reducers). Редукторы - это "чистые" функции, принимающие предыдущее состояние в качестве аргумента и возвращающие новое.

    Подробнее можно узнать из [документации](https://rajdee.gitbooks.io/redux-in-russian/content/docs/introduction/ThreePrinciples.html).

4) #### <a name="redux-simple_4"></a> **В чем разница между контекстом React и React Redux?**
    Вы можете использовать *Context* напрямую, он отлично подходит для передачи данных глубоко вложенным компонентам - в этом состоит его основное назначение.

    *Redux* - гораздо более мощный инструмент, предоставляющий большое количество возможностей, которыми не обладает API контекста. На самом деле, Redux использует контекст в своих внутренних механизмах, но не экстраполирует его в открытый интерфейс.

    Подробнее можно узнать из [документации](https://reactdev.ru/handbook/context/).

5) #### <a name="redux-simple_5"></a> **Для чего в Redux нужны константы?**
    Константы позволяют легко обнаруживать все случаи их применения в проекте при использовании IDE. Они также позволяют избегать глупых ошибок, связанных с типами - немедленно выбрасывается исключение `ReferenceError`.

    Обычно, мы сохраняем константы в отдельном файле (`constants.js` или `actionTypes.js`):
    ```javascript
    export const ADD_TODO = 'ADD_TODO'
    export const DELETE_TODO = 'DELETE_TODO'
    export const EDIT_TODO = 'EDIT_TODO'
    export const COMPLETE_TODO = 'COMPLETE_TODO'
    export const COMPLETE_ALL = 'COMPLETE_ALL'
    export const CLEAR_COMPLETED = 'CLEAR_COMPLETED'
    ```

    В Redux мы используем их в двух местах:
    1. **Во время создания операции:**
        `actions.js`:
        ```javascript
        import { ADD_TODO } from './actionTypes';

        export function addTodo(text) {
          return { type: ADD_TODO, text }
        }
        ```

    2. **В редукторах:**
        `reducer.js`:
        ```javascript
        import { ADD_TODO } from './actionTypes'

        export default (state = [], action) => {
          switch (action.type) {
            case ADD_TODO:
              return [
                ...state,
                {
                  text: action.text,
                  completed: false
                }
              ];
            default:
              return state
          }
        }
        ```

        Подробнее можно узнать из [документации](https://reactdev.ru/libs/redux/react-redux/konstanti/).

6) #### <a name="redux-simple_6"></a> **Что такое операция (action) в Redux?**
    *Actions* - это обычные JavaScript-объекты, содержащие данные приложения, которые отправляются в хранилище. Операции должны иметь свойство `type`, указывающее какой тип операции необходимо выполнить. Операции также могут содержать полезную нагрузку (payload) - данные для обновления состояния.

    Вот как может выглядеть операция по добавлению новой задачи в список:
    ```
    // здесь используется константа
    {
      type: ADD_TODO,
      text: 'Добавление задачи в список'
    }
    ```
    
    Подробнее можно узнать из [документации](https://reactdev.ru/libs/redux/basics/Actions/).

7) #### <a name="redux-simple_7"></a> **Можно ли запускать операцию(action) в редукторе?**
    Запуск операции в редукторе является *антипаттерном*. Редуктор не должен вызывать *побочных эффектов*, он должен принимать объект с названием операции и полезной нагрузкой (payload) и возвращать объект с новым состоянием. Добавление обработчиков и запуск операций в редукторе могут привести к цепной реакции и другим негативным последствиям.

8) #### <a name="redux-simple_8"></a> **Как запустить операцию(action) при загрузке?**
    Вы можете запускать операцию в методе `componentDidMount()` и проверять данные в методе `render()`:
    ```javascript
    class App extends Component {
      componentDidMount() {
        this.props.fetchData()
      }

      render() {
        return this.props.isLoaded
          ? <div>Загружено</div>
          : <div>Не загружено</div>
      }
    }

    const mapStateToProps = (state) => ({
      isLoaded: state.isLoaded
    })

    const mapDispatchToProps = { fetchData }

    export default connect(mapStateToProps, mapDispatchToProps)(App)
    ```

9) #### <a name="redux-simple_9"></a> **Почему функции, изменяющие состояние, в Redux называются редукторами?**
    Редукторы всегда возвращают аккумулированное состояние (основанное на всех предыдущих и текущей операциях). Они действуют подобно "редукторам состояния". При каждом вызове редуктора, ему в качестве аргументов передаются состояние и операция. Переданное состояние обновляется (аккумулируется с предыдущим) на основе операции, и возвращается новое состояние. Вы можете "редуцировать" несколько операций и начальное состояние (хранилища), применить эти операции к состоянию для получения результирующего состояния.

    Подробнее можно узнать из [документации](https://reactdev.ru/libs/redux/basics/Reducers/).

10) #### <a name="redux-simple_10"></a> **Как установить начальное значение в Redux?**
    Для этого необходимо передать начальное состояние как второй аргумент в метод `createStore()`:
    ```javascript
    const rootReducer = combineReducers({
      todos: todos,
      visibilityFilter: visibilityFilter
    })

    const initialState = {
      todos: [{ id: 123, name: 'пример', completed: false }]
    }

    const store = createStore(
      rootReducer,
      initialState
    )
    ```

11) #### <a name="redux-simple_11"></a> **Как получить доступ к хранилищу Redux за пределами компонента?**
    Для этого нужно экспортировать хранилище из модуля, в котором оно создано с помощью `createStore()`. Имейте ввиду, что оно не должно загрязнять глобальное пространство имен:
    ```javascript
    store = createStore(myReducer)

    export default store
    ```

12) #### <a name="redux-simple_12"></a> **Как рекомендуется получать доступ к хранилищу Redux?**
    Лучшим способом получить хранилище в компоненте является использование функции `connect()`, которая создает новый компонент, оборачивающий существующий. Этот паттерн называется *компоненты высшего порядка*, он является предпочтительным способом расширения функциональности компонента в React. Это позволяет передавать в компонент состояние и "создателей операций" (action creators), в том числе, при обновлении хранилища.

    Создадим компонент `FilterLink` с помощью `connect()`:
    ```javascript
    import { connect } from 'react-redux'
    import { setVisibilityFilter } from '../actions'
    import Link from '../components/Link'

    const mapStateToProps = (state, ownProps) => ({
      active: ownProps.filter === state.visibilityFilter
    })

    const mapDispatchToProps = (dispatch, ownProps) => ({
      onClick: () => dispatch(setVisibilityFilter(ownProps.filter))
    })

    const FilterLink = connect(
      mapStateToProps,
      mapDispatchToProps
    )(Link)

    export default FilterLink
    ```

    Поскольку такой вариант имеет несколько оптимизаций производительности и, как правило, меньше подвержен "багам", разработчики Redux почти всегда рекомендуют использовать `connect()` вместо прямого доступа к хранилищу (с помощью API контекста).
    ```javascript
    class MyComponent {
      someMethod() {
        doSomethingWith(this.context.store)
      }
    }
    ```

13) #### <a name="redux-simple_13"></a> **Как использовать метод `connect()` в Redux?**
    Для того, чтобы иметь возможность использовать хранилище в контейнере, необходимо выполнить следующие шаги:
    1. **Использовать метод `mapStateToProps()`:** он передает переменные состояния из хранилища в определенные вами пропы.
    2. **Подключить пропы к контейнеру:** объект, возвращенный `mapStateToProps()` подключается к контейнеру. Вы можете импортировать `connect()` из `react-redux`:
        ```jsx harmony
        import React from 'react'
        import { connect } from 'react-redux'

        class App extends React.Component {
          render() {
            return <div>{this.props.containerData}</div>
          }
        }

        function mapStateToProps(state) {
          return { containerData: state.data }
        }

        export default connect(mapStateToProps)(App)
        ```

14) #### <a name="redux-simple_14"></a> **Что такое селекторы (selectors) Redux и зачем их использовать?**
    *Selectors* - это функции, принимающие состояние Redux в качестве аргумента и возвращающие некоторые данные для передачи компоненту.

    Например, так можно извлечь данные пользователя из состояния:
    ```javascript
    const getUserData = state => state.user.data
    ```

    Селекторы имеют два главных преимущества:
      1. Селектор может вычислять производные данные, позволяя Redux записывать в хранилище минимально возможное состояние
      2. Селектор не выполняет повторных вычислений до тех пор, пока не изменится один из его аргументов

15) #### <a name="redux-simple_15"></a> **Как структурировать директории верхнего уровня в Redux?**
    Большинство приложений имеют несколько "топовых" директорий:
      1. **components**: используется для "тупых" компонентов, не знающих о Redux
      2. **containers**: используется для "умных" компонентов, подключенных к Redux
      3. **actions**: используется для всех создателей операций - названия файлов указывают на соответствующие части приложения
      4. **reducers**: используется для всех редукторов - названия коррелируют с ключами состояния
      5. **store**: используется для инициализации хранилища

    Такая структура прекрасно подходит для небольших и средних приложений.

16) #### <a name="redux-simple_16"></a> **Обязательно ли хранить состояние всех компонентов в хранилище Redux?**
    Данные приложения следует хранить в хранилище Redux, а состояние компонентов пользовательского интерфейса в соответствующих компонентах. У создателя Redux Дэна Абрамова по этому поводу есть статья под названием "Следует ли вам использовать Redux?"

17) #### <a name="redux-simple_17"></a> **В чем разница между компонентом и контейнером в React Redux?**
    *Component* - это классовый или функциональный компонент, описывающий визуальное представление приложения.

    *Container* - это неофициальный термин для описания компонента, подключенного к хранилищу Redux. Контейнеры "подписываются" на обновление состояния Redux и "запускают" (dispatch) операции, они, как правило, не рендерят DOM-элементы: они делегируют рендеринг дочерним компонентам, отвечающим за визуализацию.

18) #### <a name="redux-simple_18"></a> **Что такое Redux Form?**
    *Redux Form* работает с React и Redux, позволяя формам в React хранить состояние в Redux. Redux Form может использоваться с обычными HTML5-инпутами, а также с популярными UI-фреймворками, такими как Material UI, React Widgets и React Bootstrap.

19) #### <a name="redux-simple_19"></a> **Назовите основные возможности, предоставляемые Redux Form?**
    Вот некоторые из основных особенностей Redux Form:
      1. Значения полей записываются в хранилище Redux.
      2. Синхронная/асинхронная валидация полей и отправка формы.
      3. Форматирование, разбор и нормализация значений полей.

20) #### <a name="redux-simple_20"></a> **Что такое Redux Thunk?**
    *Redux Thunk* - это промежуточное программное обеспечение, которое позволяет писать "создателей операций(actions)", возвращающих функции вместо операций. Thunk может использоваться для отложенного или условного запуска операции. Внутренняя функция в качестве параметров принимает методы хранилища `dispatch()` и `getState()`.

21) #### <a name="redux-simple_21"></a> **Что такое Redux DevTools?**
    *Redux DevTools* - это Redux-окружение для "путешествий во времени" и "живого" редактирования кода с возможностью "горячей" перезагрузки, повторения операций и "кастомизируемым" интерфейсом. Если вы не хотите возиться с установкой Redux DevTools и его интеграцией в свой проект, присмотритесь к соответствующим расширениям для Chrome и Firefox.

22) #### <a name="redux-simple_22"></a> **Назовите основные возможности Redux DevTools**
    Вот некоторые из основных возможностей Redux DevTools:
      1. Позволяют инспектировать каждое состояние и полезную нагрузку операции.
      2. Позволяют возвращаться назад, "отменяя" выполнение операций.
      3. При изменении кода редуктора осуществляется повторное вычисление каждой "зафиксированной" операции.
      4. Если редуктор выбросил исключение, вы сможете увидеть, в процессе выполнения какой операции это произошло, и в чем заключается ошибка.
      5. С помощью метода `persistState()` можно сохранить сессию отладки между перезагрузками страницы.

23) #### <a name="redux-simple_23"></a> **Как добавить несколько middleware в Redux?**
    Для этого можно использовать метод `applyMiddleware()`.

    Например, можно добавить `redux-thunk` и `logger`, передав их в качестве аргументов в `applyMiddleware()`:
    ```javascript
    import { createStore, applyMiddleware } from 'redux'
    const createStoreWithMiddleware = applyMiddleware(thunk, logger)(createStore)
    ```

    Подробнее можно узнать из [документации](https://reactdev.ru/libs/redux/advanced/Middleware/).


### **Продвинутые вопросы**
1) #### <a name="redux-advanced_1"></a> **Проведите сравнение Redux и Flux**
    Отличия между Redux и Flux можно свести к следующему:
      1. **Недопустимость мутаций:** во Flux состояние может быть изменяемым, а Redux требует, чтобы состояние было иммутабельным, и многие библиотеки для Redux исходят из предположения, что вы никогда не будете менять состояние напрямую. Вы можете обеспечить иммутабельность состояния с помощью таких пакетов, как `redux-immutable-state-invariant`, `Immutable.js` или условившись с другими членами команды о написании иммутабельного кода.
      2. **Осторожность в выборе библиотек:** Flux не пытается решать такие проблемы, как повторное выполнение/отмена выполнения, стабильность (постоянство) кода или проблемы, связанные с обработкой форм, явно, а Redux имеет возможность к расширению с помощью промежуточного программного обеспечения (middleware) и предохранителей хранилища, что породило богатую экосистему.
      3. **Отсутствие интеграции с Flow:** Flux позволяет осуществлять очень выразительную статическую проверку типов, а Redux пока не поддерживает такой возможности.

2) #### <a name="redux-advanced_2"></a> **Назовите недостатки паттерна MVW (Model-View-Whatever: MVC, MVP, MVVM и т.д.)**
    1. Манипуляции с DOM являются очень дорогостоящими, что делает приложение медленным и неэффективным.
    2. Для обеспечения возможности использования обратных зависимостей была разработана очень сложная модель вокруг моделей и представлений.
    3. Происходит изменение большого количества данных в приложениях для совместной работы (таких как Google Docs).
    4. Не существует простого способа отменять действия без добавления большого количества дополнительного кода.

3) #### <a name="redux-advanced_3"></a> **Существует ли что-либо общее между Redux и RxJS?**
    Названные библиотеки созданы для разных целей. Однако, между ними есть кое-что общее.

    Redux - это инструмент для управления состоянием приложения. Как правило, он используется в качестве архитектурного решения для пользовательского интерфейса. Думайте о нем как об альтернативе (наполовину) Angular. RxJS - это библиотека реактивного программирования. Обычно, она используется для выполнения асинхронных задач в JavaScript. Думайте о ней как об альтернативе промисам. Redux использует реактивную парадигму, поскольку хранилище является реактивным. Хранилище наблюдает за операциями с расстояния и изменяет себя. RxJS следует той же парадигме, но вместо того, чтобы выступать в роли архитектуры, он предоставляет основные строительные блоки, наблюдаемые объекты (observables), для реализации указанного паттерна.

4) #### <a name="redux-advanced_4"></a> **Как обнулить состояние в Redux?**
    Для этого необходимо создать *корневой редуктор* (root reducer), делегирующий обработку операций редуктору, генерируемому методом `combineReducers()`.

    Создадим `rootReducer()`, возвращающий начальное состояние после операции `USER_LOGOUT`. Как мы знаем, редукторы возвращают начальное состояние при вызове с `undefined` в качестве первого аргумента, независимо от операции:
    ```javascript
    const appReducer = combineReducers({
      /* редукторы верхнего уровня приложения */
    })

    const rootReducer = (state, action) => {
      if (action.type === 'USER_LOGOUT') {
        state = undefined
      }

      return appReducer(state, action)
    }
    ```

    В случае использования `redux-persist`, вам, возможно, также потребуется очистить хранилище. `redux-persist` сохраняет копию состояния в движке хранилища. Поэтому сначала нужно импортировать соответствующий движок, затем разобрать состояние перед установкой его значение в `undefined` и, наконец, очистить каждый ключ состояния хранилища:
    ```javascript
    const appReducer = combineReducers({
      /* редукторы верхнего уровня приложения */
    })

    const rootReducer = (state, action) => {
      if (action.type === 'USER_LOGOUT') {
        Object.keys(state).forEach(key => {
          storage.removeItem(`persist: ${key}`)
        })

        state = undefined
      }

      return appReducer(state, action)
    }
    ```

5) #### <a name="redux-advanced_5"></a> **Для чего используется символ *@* в декораторе `connect` Redux?**
    Символ *@* указывает на то, что мы имеем дело с декоратором JavaScript. *Decorators* делают возможным аннотирование и модификацию классов, их полей и методов во время определения класса.

    Рассмотрим примеры настройки Redux без и с использованием декоратора:
    - **Без декоратора:**
        ```javascript
        import React from 'react'
        import * as actionCreators from './actionCreators'
        import { bindActionCreators } from 'redux'
        import { connect } from 'react-redux'

        function mapStateToProps(state) {
          return { todos: state.todos }
        }

        function mapDispatchToProps(dispatch) {
          return { actions: bindActionCreators(actionCreators, dispatch) }
        }

        class MyApp extends React.Component {
          // ...
        }

        export default connect(mapStateToProps, mapDispatchToProps)(MyApp)
        ```

    - **C декоратором:**

        ```javascript
        import React from 'react'
        import * as actionCreators from './actionCreators'
        import { bindActionCreators } from 'redux'
        import { connect } from 'react-redux'

        function mapStateToProps(state) {
          return { todos: state.todos }
        }

        function mapDispatchToProps(dispatch) {
          return { actions: bindActionCreators(actionCreators, dispatch) }
        }

        @connect(mapStateToProps, mapDispatchToProps)
        export default class MyApp extends React.Component {
          // ...
        }
        ```

    Приведенные примеры почти идентичны, за исключением использования декоратора. Синтаксис декораторов пока не стандартизирован, является экспериментальным и может измениться в будущем (данное предложение находится на *3 стадии рассмотрения*). Для поддержки декораторов можно использовать *Babel*.

6) #### <a name="redux-advanced_6"></a> **Как сделать AJAX-запрос в Redux?**
    Для этого можно использовать промежуточное программное обеспечение `redux-thunk`, позволяющее определять асинхронные операции.

    Рассмотрим пример запроса определенного аккаунта с помощью `fetch API`:
    ```javascript
    export function fetchAccount(id) {
      return dispatch => {
        dispatch(setLoadingAccountState()) // показываем индикатор загрузки
        fetch(`/account/${id}`, (response) => {
          dispatch(doneFetchingAccount()) // скрываем индикатор
          if (response.status === 200) {
            dispatch(setAccount(response.json())) // обновляем состояние полученными данными
          } else {
            dispatch(someError)
          }
        })
      }
    }

    function setAccount(data) {
      return { type: 'SET_ACCOUNT', data }
    }
    ```

7) #### <a name="redux-advanced_7"></a> **В чем разница между `mapStateToProps()` и `mapDispatchToProps()`?**
    `mapStateToProps()` - это утилита, помогающая компонентам получать обновленное состояние (которое было обновлено другим компонентом):
    ```javascript
    const mapStateToProps = (state) => {
      return {
        todos: getVisibleTodos(state.todos, state.visibilityFilter)
      }
    }
    ```

    `mapDispatchToProps()` - утилита, помогающая компонентам вызывать операции (которые могут привести к обновлению состояния приложения):
    ```javascript
    const mapDispatchToProps = (dispatch) => {
      return {
        onTodoClick: (id) => {
          dispatch(toggleTodo(id))
        }
      }
    }
    ```

    Для `mapDispatchToProps()` рекомендуется всегда использовать короткую форму записи объекта.

    Redux оборачивает ее в другую функцию, которая выглядит как `(…args) => dispatch(onTodoClick(…args))`, и передает эту обертку в качестве пропа в компонент:
    ```javascript
      const mapDispatchToProps = ({
        onTodoClick
      })
    ```

8) #### <a name="redux-advanced_8"></a> **Какие способы существуют для написания `mapDispatchToProps()`?**
    Существует несколько способов привязать "создателей операций" к методу `dispatch()` в `mapDispatchToProps()`.

    Ниже представлены возможные варианты:
    ```javascript
    const mapDispatchToProps = (dispatch) => ({
    action: () => dispatch(action())
    })
    ```

    ```javascript
    const mapDispatchToProps = (dispatch) => ({
    action: bindActionCreators(action, dispatch)
    })
    ```

    ```javascript
    const mapDispatchToProps = { action }
    ```

    Третий вариант является сокращением первого.

9) #### <a name="redux-advanced_9"></a> **Для чего используется параметр `ownProps` в методах `mapStateToProps()` и `mapDispatchToProps()`?**
    При определении параметра `ownProps` React Redux передает пропы в компонент в функциях "подключения". Поэтому, если вы используете подключенный компонент:
    ```jsx harmony
    import ConnectedComponent from './containers/ConnectedComponent';

    <ConnectedComponent user='Иван' />
    ```

    `ownProps` внутри функций `mapStateToProps()` и `mapDispatchToProps()` будет объектом:
    ```javascript
    { user: 'Иван' }
    ```

    Вы можете использовать этот объект для определения значения, возвращаемого указанными функциями.

10) #### <a name="redux-advanced_10"></a> **Что такое `redux-saga`?**
    `redux-saga` - это библиотека, позволяющая легче и быстрее выполнять побочные эффекты (асинхронную логику, вроде получения данных и доступа к кэшу браузера) в React/Redux-приложениях.

    Она доступна в NPM:
    ```console
    $ yarn add redux-saga
    // или
    $ npm i redux-saga
    ```

11) #### <a name="redux-advanced_11"></a> **Определите ментальную модель redux-saga**
    *Saga* - своего рода отдельный поток (выполнения кода) в приложении, отвечающий исключительно за побочные эффекты. `redux-saga` - это *middleware* для Redux, это означает, что данный "тред" может запускаться, приостанавливаться и отменяться из основного приложения с помощью обычных операций Redux. Он имеет доступ к состоянию приложения и может инициировать запуск операций.

12) #### <a name="redux-advanced_12"></a> **В чем разница между методами `call()` и `put()` в redux-saga?**
    `call()` и `put()` являются функциями создания эффектов. `call()` используется для создания эффекта описания, указывающего *middleware* вызвать промис. `put()` создает эффект, указывающий *middleware* запустить операцию.

    Рассмотрим, как эти эффекты работают применительно к запросу пользовательских данных:
    ```javascript
    function* fetchUserSaga(action) {
      // функция `call()` получает аргументы, которые передаются функции `api.fetchUser()`,
      // указываем middleware вызвать промис, после чего разрешенное значение присваивается переменной userData
      const userData = yield call(api.fetchUser, action.userId)

      // указываем middleware запустить соответствующую операцию
      yield put({
        type: 'FETCH_USER_SUCCESS',
        userData
      })
    }
    ```

13) #### <a name="redux-advanced_13"></a> **В чем разница между `redux-saga` и `redux-thunk`?**
    *Redux Thunk* и *Redux Saga* предназначены для работы с побочными эффектами. В большинстве сценариев, Thunk для этого пользуется *промисами*, а Saga - *генераторами*. Thunk проще в использовании и промисы лучше знакомы большинству разработчиков, Saga предоставляет больше возможностей, но требуется хорошо разбираться в генераторах. Названные *middlewares* могут использоваться совместно: можно начать с использования Thunk и, при необходимости, перейти на Saga.

14) #### <a name="redux-advanced_14"></a> **Чем Relay отличается от Redux?**
    *Relay* похож на *Redux* тем, что оба используют единственное хранилище. Основное отличие состоит в том, что Relay управляет состоянием через сервер, доступ к состоянию (чтение данных) и его изменение осуществляется через *GraphQL-запросы*. Relay кэширует данные в целях оптимизации их получения, запрашивая только изменившиеся данные и ничего более.
***


## **React Router**
### **Простые, общие вопросы**
1) #### <a name="react-router-simple_1"></a> **Что такое React Router?**
    React Router - это мощная библиотека маршрутизации, построенная на основе React, которая помогает добавлять новые страницы и перемещаться между ними очень быстро, при сохранении синхронизации между адресом страницы и ее представлением.

    Подробнее можно узнать из [документации](https://reactdev.ru/libs/react-router/).

2) #### <a name="react-router-simple_2"></a> **Чем React Router отличается от библиотеки `history`?**
    React Router - это обертка библиотеки `history`, которая обеспечивает взаимодействие с браузерным `window.history` и хэш-историей. Она также позволяет сохранять историю в памяти при отсутствии в окружении глобальной истории, например, при разработке мобильных приложений (React Native) и юнит-тестировании с помощью Node.

3) #### <a name="react-router-simple_3"></a> **Что такое `Router` в React Router 4?**
    React Router 4 предоставляет 3 компонента `Router`:
      1. `BrowserRouter`
      2. `HashRouter`
      3. `MemoryRouter`

    Указанные компоненты создают экземпляры *browser*, *hash* и *memory* истории. React Router 4 делает свойства и методы экземпляра `history` связанными с вашим мартшрутизатором через контекст в объекте `router`.

    Подробнее можно узнать из [документации](https://reactdev.ru/libs/react-router/#_4).

4) #### <a name="react-router-simple_4"></a> **Для чего предназначены методы `push()` и `replace()` объекта History?**
    Экземпляр истории имеет два метода для навигации:
      1. `push()`
      2. `replace()`

    Если думать об истории как о массиве посещенных локаций, то метод `push()` добавляет в массив новую локацию, а `replace()` заменяет текущую локацию новой.

5) #### <a name="react-router-simple_5"></a> **Как реализовать программную навигацию с помощью React Router 4?**
    Существует, как минимум, три способа реализовать программный роутинг/навигацию в компоненте:
    1. **Использование функции высшего порядка `withRouter()`:**

        `withRouter()` внедряет объект истории в качестве пропа в компонент. Этот объект предоставляет методы `push()` и `replace()`, позволяющие избежать использования контекста:
        ```jsx harmony
        import { withRouter } from 'react-router-dom' // это также работает с 'react-router-native'

        const Button = withRouter(({ history }) => (
          <button
            type='button'
            onClick={() => { history.push('/new-location') }}
          >
            Нажми на меня!
          </button>
        ))
        ```
    
    2. **Использование компонента `Route` и рендер-пропов:**

        Компонент `Route` предоставляет такой же проп, что и `withRouter()`, так что у вас будет возможность получить доступ к методам истории через проп `history`.
        ```jsx harmony
        import { Route } from 'react-router-dom'

        const Button = () => (
          <Route render={({ history }) => (
            <button
              type='button'
              onClick={() => { history.push('/new-location') }}
            >
              Нажми на меня!
            </button>
          )} />
        )
        ```

    3. **Использование контекста:**

        Данный подход использовать не рекомендуется, он считается нестабильным:
        ```jsx harmony
        const Button = (props, context) => (
          <button
            type='button'
            onClick={() => {
              context.history.push('/new-location')
            }}
          >
            Нажми на меня!
          </button>
        )

        Button.contextTypes = {
          history: React.PropTypes.shape({
            push: React.PropTypes.func.isRequired
          })
        }
        ```

6) #### <a name="react-router-simple_6"></a> **Как получить параметры строки запроса в React Router 4?**
    Возможность разбирать строку запроса была удалена из React Router 4, поскольку разработчики на протяжении нескольких лет просили добавить другую реализацию. Поэтому разработчикам была предоставлена возможность самостоятельного выбора реализации. Рекомендуемым подходом является использование библиотеки `query-srting`:
    ```javascript
    const queryString = require('query-string');
    const parsed = queryString.parse(props.location.search);
    ```

    Если вы предпочитаете нативные решения, то можете использовать `URLSearchParams()`:
    ```javascript
    const params = new URLSearchParams(props.location.search)
    const foo = params.get('name')
    ```

7) #### <a name="react-router-simple_7"></a> **Когда можно получить предупреждение "Router может содержать только один дочерний элемент"?**
    Маршруты (routes) должны быть обернуты в блок `Switch` (переключатель), поскольку этот блок является уникальным и рендерит только компонент по определенному маршруту.

    Прежде всего, необходимо импортировать `Switch`:
    ```javascript
    import { Switch, Router, Route } from 'react-router'
    ```

    Затем определить в нем маршруты:
    ```jsx harmony
    <Router>
      <Switch>
        <Route {/* ... */} />
        <Route {/* ... */} />
      </Switch>
    </Router>
    ```

    Подробнее можно узнать из [документации](https://reactdev.ru/libs/react-router/#_6).

8) #### <a name="react-router-simple_8"></a> **Как передать параметры методу `history.push()` в React Router 4?**
    В процессе навигации вы можете передавать объекту `history` некоторые пропы:
    ```javascript
    this.props.history.push({
      pathname: '/template',
      search: '?name=sudheer',
      state: { detail: response.data }
    })
    ```

    Свойство `search`, например, используется для передачи параметров строки запроса.

    Подробнее можно узнать из [документации](https://reactdev.ru/libs/react-router/#history).

9) #### <a name="react-router-simple_9"></a> **Как реализовать *стандартную* или *NotFound* страницу?**
    `Switch` рендерит компонент по первому совпавшему маршруту. `Route` без пути всегда будет совпадать. Поэтому можно просто опустить атрибут `path` или же указать `/*` в качестве его значения:
    ```jsx harmony
    <Switch>
      <Route exact path="/" component={Home}/>
      <Route path="/user" component={User}/>
      <Route component={NotFound} />
    </Switch>
    ```

10) #### <a name="react-router-simple_10"></a> **Как получить объект истории в React Router 4?**
    Для получения объекта истории необходимо выполнить следующие шаги:
      1. Создать модуль, экспортирующий объект `history`, и импортировать этот модуль в проект.

          Создаем файл `history.js`:
          ```javascript
          import { createBrowserHistory } from 'history'

          export default createBrowserHistory({
            /* здесь может быть объект с настройками */
          })
          ```
    2. Вместо встроенных роутеров следует использовать компонент `Router`. Импортируем `history` в файл `index.js`:
        ```jsx harmony
        import { Router } from 'react-router-dom'
        import history from './history'
        import App from './App'

        ReactDOM.render((
          <Router history={history}>
            <App />
          </Router>
        ), holder)
        ```
    3. Вы также можете использовать метод `push()` объекта `history` по аналогии со встроенным объектом истории:
        ```javascript
        // some-other-file.js
        import history from './history'

        history.push('/go-here')
        ```

11) #### <a name="react-router-simple_11"></a> **Как реализовать автоматическое перенаправление после выполнения входа в систему?**
    Пакет `react-router` предоставляет компонент `Redirect`. Рендеринг данного компонента приводит к перемещению в новую локацию. Как и в случае с серверными перенаправлениями, новая локация перезапишет текущую в стеке истории:
    ```javascript
    import React, { Component } from 'react'
    import { Redirect } from 'react-router'

    export default class LoginComponent extends Component {
      render() {
        if (this.state.isLoggedIn === true) {
          return <Redirect to="/your/redirect/page" />
        } else {
          return <div>Войдите, пожалуйста</div>
        }
      }
    }
    ```

12) #### <a name="react-router-simple_12"></a> **В чем отличие между `react-router`, `react-router-dom` и `react-router-native`?**
    - `react-router` - Содержит общие элементы ядра для версий dom и native.
    - `react-router-dom` - Версия dom, разработана для браузеров или веб-приложений.
    - `react-router-native` - Версия native, разработана для мобильных приложений.

    **`Важно знать!`**
    Отдельно устанавливать `react-router` не нужно. Пакет `react-router-dom` включает в себя всё необходимое для работы.
***
# Общий список вопросов JS

[**Какие методы HTTP-запросов вы знаете?**](#js-question_1)

[**Какие версии HTTP-протокола вам известны?**](#js-question_2)

[**Какие знаете коды ответа (состояния) HTTP?**](#js-question_3)

[**Что такое Cross-Origin Resource Sharing? Как устранить проблемы с CORS?**](#js-question_4)

[**Что такое cookie?**](#js-question_5)

[**Какой максимальный размер cookie?**](#js-question_6)

[**Что означает директива 'use strict'?**](#js-question_7)

[**Что такое статическая и динамическая типизации?**](#js-question_8)

[**Как клиент взаимодействует с сервером?**](#js-question_9)

[**Что такое REST?**](#js-question_10)

[**Объяснить понятие мутабельность/иммутабельность? Какие типы являются мутабельными и наоборот?**](#js-question_11)

[**Как искать ошибки в коде? Используете ли вы дебаггер?**](#js-question_12)

[**Какие существуют типы данных в JS?**](#js-question_13)

[**Как проверить, является ли объект массивом?**](#js-question_14)

[**Как проверить, что переменная равна NaN?**](#js-question_15)

[**Сравните ключевые слова var, let, const.**](#js-question_16)

[**Что такое область видимости?**](#js-question_17)

[**Что такое деструктуризация?**](#js-question_18)

[**Для чего предназначены методы setTimeout и setInterval?**](#js-question_19)

[**Сравните подходы работы с асинхронным кодом: callbacks vs promises vs async / await.**](#js-question_20)

[**Можно ли записывать новые свойства / функции в прототипы стандартных классов (Array, Object и т. д.)? Почему нет? В каких случаях это делать можно? Как обезопасить себя, если нужно расширить прототип?**](#js-question_21)

[**Назовите методы массивов, какие помните, и скажите, для чего они нужны.**](#js-question_22)

[**Какие методы перебора массива знаете? В чем их отличие?**](#js-question_23)

[**Как работают операторы присваивания / сравнения / строчные / арифметические / битовые и т. д.?**](#js-question_24)

[**Что означает глубокая (deep) и поверхностная (shallow) копия объекта? Как сделать каждую из них?**](#js-question_25)

[**Какая разница между декларацией функции (function declaration) и функциональным выражением (function expression)?**](#js-question_26)

[**Что такое анонимная функция?**](#js-question_27)

[**Расскажите о стрелочных функциях (arrow function). В чем заключаются отличия стрелочных функций от обычных?**](#js-question_28)

[**Что такое и для чего используют IIFE (Immediately Invoked Function Expression) самовызывающаяся функция?**](#js-question_29)

[**Что такое hoisting, как он работает для переменных и функций?**](#js-question_30)

[**Что такое замыкание (closure) и какие сценарии его использования?**](#js-question_31)

[**Что такое рекурсия?**](#js-question_32)

[**Что означает ключевое слово this?**](#js-question_33)

[**Что такое потеря контекста, когда происходит и как ее предотвратить?**](#js-question_34)

[**Методы функций bind / call / apply - зачем и в чем разница?**](#js-question_35)

[**Что такое DOM?**](#js-question_36)

[**Сравните атрибуты подключения скрипта async и defer в HTML-документе.**](#js-question_37)

[**Какая разница между свойствами HTML-элементов innerHTML и innerText?**](#js-question_38)

[**Опишите процесс всплытия (bubbling) событий в DOM.**](#js-question_39)

[**Как остановить всплытие (bubbling) события?**](#js-question_40)

[**Как остановить дефолтную обработку события?**](#js-question_41)

[**Чему равен this в обработчике событий (event handler)?**](#js-question_42)

[**Что такое LocalStorage и SessionStorage? Какой максимальный размер LocalStorage?**](#js-question_43)

[**Как получить высоту блока? Его положение относительно границ документа?**](#js-question_44)

[**Что такое webpack?**](#js-question_45)

[**Каким образом можно загрузить проект из Git репозитория?**](#js-question_46)

[**Как получить свежее состояние ветки?**](#js-question_47)

[**В какой ветке необходимо начинать работу над задачей?**](#js-question_48)

[**Как загрузить ветку на репозиторий?**](#js-question_49)

[**Что такое рекурсивная функция?**](#js-question_50)

[**Каким образом функция может вызывать сама себя?**](#js-question_51)

[**К чему может привести некорректно спроектированная рекурсивная функция?**](#js-question_52)

[**Что такое замыкание?**](#js-question_53)

[**Существует ли разница в работе с командной строкой между различными операционными системами (Windows, Linux, MacOS)?**](#js-question_54)

[**Что такое переменная окружения?**](#js-question_55)

[**Каким образом можно установить переменную окружения?**](#js-question_56)

[**Возможно ли поместить переменные окружения в определенный файл, который будет загружен непосредственно во время запуска приложения?**](#js-question_57)

[**Возможно ли создать несколько таких файлов таким образом, чтобы необходимый выбирался автоматически в зависимости от того, под какое окружение происходи сборка или запуск приложения?**](#js-question_58)

[**Что такое HTTP?**](#js-question_59)

[**Назови самые распространенные методы HTTP запроса?**](#js-question_60)

[**Назови самые распространенные статусы ответа?**](#js-question_61)

[**Что такое кроссдоменные запросы?**](#js-question_62)

[**Какие типы данных существуют в JavaScript?**](#js-question_63)

[**Корректно ли утверждение, что тип данных переменной может быть динамичен?**](#js-question_64)

[**Какими способами можно представить число? (изменить формулировку)**](#js-question_65)

[**В чем разница между typeof и instanceof?**](#js-question_66)

[**В чем разница между числом (number) и Number?**](#js-question_67)

[**Каким образом можно определить переменную?**](#js-question_68)

[**Какая разница между var, let и const?**](#js-question_69)

[**Какие числа при приведении к boolean будут обработаны как true, а какие как false?**](#js-question_70)

[**Объясни принцип работы следующей конструкции:**](#js-question_71)

[**Что произойдет при сложении строки с числом?**](#js-question_72)

[**Что произойдет при разности строки и числа?**](#js-question_73)

[**Каким оператором можно произвести преобразование к числу?**](#js-question_74)

[**В чем разница между "==" и "==="?**](#js-question_75)

[**Как можно сравнить объекты?**](#js-question_76)

[**Что такое условный (тернарный) оператор?**](#js-question_77)

[**Назови основные логические операторы?**](#js-question_78)

[**Как узнать, можно ли вызвать переменную `fn` как функцию?**](#js-question_79)

[**Произойдет ли ошибка в процессе работы данного скрипта?**](#js-question_80)

[**Какая разница между функцией, методом и конструктором?**](#js-question_81)

[**Что такое IIFE (immediately invoked function expression)?**](#js-question_82)

[**Каким образом можно получить список всех аргументов функции из ее тела?**](#js-question_83)

[**Можно ли подменить контекст выполнения функции?**](#js-question_84)

[**Что будет выведено в результате работы следующего кода:**](#js-question_85)

[**Что будет выведено в результате работы следующего кода:**](#js-question_86)

[**Что такое область видимости?**](#js-question_87)

[**Что произойдет в результате работы следующего кода:**](#js-question_88)

[**Что будет выведено в результате работы следующего кода:**](#js-question_89)

[**Что будет выведено в результате работы следующего кода:**](#js-question_90)

[**Что будет выведено в результате работы следующего кода:**](#js-question_91)

[**Может ли функция быть объявлена внутри другой функции?**](#js-question_92)

[**Каким образом можно обработать ошибку?**](#js-question_93)

[**Каким образом можно выбросить исключение?**](#js-question_94)

[**Какого типа исключения можно выбрасывать?**](#js-question_95)

[**Обязательно ли использовать блок catch?**](#js-question_96)

[**Обязательно ли использовать блок finally?**](#js-question_97)

[**Возможно ли создавать вложенные try...catch?**](#js-question_98)

[**Что такое строгий режим?**](#js-question_99)

[**К чему может быть применен строгий режим?**](#js-question_100)

[**Как активировать строгий режим?**](#js-question_101)

[**Какие ограничения вводит строгий режим?**](#js-question_102)

[**Как создать массив?**](#js-question_103)

[**Как отличить массив от объекта?**](#js-question_104)

[**Изменится ли длина массива, если задать новое значение для array.length?**](#js-question_105)

[**Какими способами можно создать массив из n элементов?**](#js-question_106)

[**Каким способом можно создать новый массив на основании существующего так, чтобы он не содержал повторяющиеся значения?**](#js-question_107)

[**Каким образом можно поэлементно обойти массив?**](#js-question_108)

[**Каким образом можно объединить 2 и более массива?**](#js-question_109)

[**Возможно ли объединить элементы массива в текстовую строку?**](#js-question_110)

[**Как добавить элемент в конец массива?**](#js-question_111)

[**Как отсортировать массив?**](#js-question_112)

[**Как найти элемент в массиве?**](#js-question_113)

[**Может ли элемент массива быть массивом?**](#js-question_114)

[**Является ли arguments массивом?**](#js-question_115)

[**Какие словари существуют в JavaScript?**](#js-question_116)

[**Какие коллекции существуют в JavaScript?**](#js-question_117)

[**Какие имена свойств могут быть у объектов?**](#js-question_118)

[**Каким образом можно перечислить свойства объекта?**](#js-question_119)

[**Как узнать, существует ли у объекта определенное свойство или метод?**](#js-question_120)

[**Какими способами можно создать объект?**](#js-question_121)

[**Каким образом можно запретить модификацию объекта?**](#js-question_122)

[**Каким образом можно совместить два (и более) объекта в один**](#js-question_123)

[**Корректно ли использовать такой код для удаления элементов массива, и если нет то почему:**](#js-question_124)

[**Как создать объект при помощи функции-конструктора?**](#js-question_125)

[**Обязательно ли использовать круглые скобки при вызове конструктора?**](#js-question_126)

[**Что вернет пустая функция, вызванная с оператором new?**](#js-question_127)

[**Что происходит при интерпретации "new Foo()"?**](#js-question_128)

[**Как называется объект, от которого произошло наследование?**](#js-question_129)

[**Корректно ли выражение, что все объекты в конечном итоге унаследованы от какого-то одного? Если да, то от какого?**](#js-question_130)

[**Каким образом ищется свойство в объекте при попытке доступа к нему?**](#js-question_131)

[**Что произойдет при вызове o.m()?**](#js-question_132)

[**Что произойдет при вызове p.m()?**](#js-question_133)

[**Создайте класс Person, реализующий прототипный метод "sayHello" и экземпляр этого класса средствами ES5**](#js-question_134)

[**Создайте класс Person, реализующий прототипный метод "sayHello" и экземпляр этого класса средствами ES6**](#js-question_135)

[**Каким образом можно определить класс?**](#js-question_136)

[**Какими способами реализуется наследование?**](#js-question_aa)

[**Распространяется ли всплытие (hosting) на классы?**](#js-question_137)

[**Можно ли принудительно включить строгий режим для тела класса?**](#js-question_138)

[**Что такое constructor?**](#js-question_139)

[**Как определить статический метод?**](#js-question_140)

[**Как обратиться к родительскому классу средствами ES6?**](#js-question_141)

[**Что такое ООП?**](#js-question_142)

[**Что означает наследование?**](#js-question_143)

[**Что означает инкапсуляция?**](#js-question_bb)

[**Что означает полиморфизм?**](#js-question_144)

[**Что такое Promise?**](#js-question_145)

[**Какие состояния есть у Promise?**](#js-question_146)

[**Каким образом можно создать Promise?**](#js-question_147)

[**Каким образом можно выполнить несколько обещаний таким образом, чтобы дождаться выполнения всех или отклонения хотя бы одного?**](#js-question_148)

[**Что будет являться результатом выполнения Promise.all?**](#js-question_149)

[**Верно ли утверждение, что Promise.all будет завершать обещания одно за одним, по цепочке?**](#js-question_150)

[**Каким образом можно дождаться выполнения только одного обещания из списка, которое произойдет быстрее всего?**](#js-question_151)

[**Каким образом можно получить отклоненное обещание из произвольной переменной?**](#js-question_152)

[**Каким образом можно получить успешно завершенное обещание из произвольной переменной?**](#js-question_153)

[**Возможно ли выполнить вызов непосредственно после завершения промиса в не зависимости от того, ушел ли он в ошибку или был resolved?**](#js-question_154)

[**Что такое функция обратного вызова (callback)?**](#js-question_155)

[**Что такое callback hell?**](#js-question_156)

[**Как бороться с callback hell?**](#js-question_157)

[**Что такое промисификация?**](#js-question_158)

[**Что такое цикл событий (event loop)?**](#js-question_159)

[**Что такое генератор?**](#js-question_160)

[**Как определить функцию-генератор?**](#js-question_161)

[**Можно ли инстанцировать (вызвать как функцию-конструктор) генератор?**](#js-question_162)

[**Что такое протокол "Итератор"?**](#js-question_163)

[**Что такое модуль?**](#js-question_164)

[**Что такое import?**](#js-question_165)

[**Какими способами можно выполнить импорт?**](#js-question_166)

[**Что такое export?**](#js-question_167)

[**Какие типы экспорта существуют?**](#js-question_168)

[**Какими способами можно произвести экспорт?**](#js-question_169)

[**Каким образом можно выполнить сетевой запрос?**](#js-question_170)

[**Что такое XMLHttpRequest?**](#js-question_171)

[**Каким образом можно отправить XMLHttpRequest?**](#js-question_172)

[**Что такое FormData?**](#js-question_173)

[**Каким образом можно создать запрос при помощи Fetch API?**](#js-question_174)

[**Каким образом при использовании Fetch API можно выполнить запрос с CORS?**](#js-question_175)

[**Каким образом при использовании Fetch API можно выполнить запрос с CORS?**](#js-question_cc)

[**Что такое DOM?**](#js-question_176)

[**Как можно обратиться к DOM?**](#js-question_177)

[**Можно ли изменить стили DOM элемента?**](#js-question_178)

[**Можно ли получить доступ ко всем стилям, примененным к документу?**](#js-question_179)

[**Какими способом можно найти элемент DOM?**](#js-question_180)

[**Что такое элемент?**](#js-question_181)

[**Что такое атрибуты элемента?**](#js-question_182)

[**Как получить доступ к атрибутам элемента?**](#js-question_183)

[**Каким образом можно узнать ширину элемента?**](#js-question_184)

[**Можно ли изменив значение "element.clientWidth" изменить ширину элемента?**](#js-question_185)

[**Каким образом можно узнать размер элемента?**](#js-question_186)

[**Возможно ли программно произвести скроллинг?**](#js-question_187)

[**Что такое событие (Event)?**](#js-question_jj)

[**Каким образом можно создать событие?**](#js-question_188)

[**Каким образом можно инициировать ("запустить") событие?**](#js-question_189)

[**Каким образом можно создать обработчик события?**](#js-question_190)

[**Возможно ли назначить сразу несколько обработчиков событий на один и тот же элемент?**](#js-question_191)

[**Возможно ли удалить обработчик события?**](#js-question_192)

[**Что такое элемент формы?**](#js-question_193)

[**Какое значение enctype должно быть установлено, если форма содержит input с типом "Файл"?**](#js-question_194)

[**Можно ли разрешить форме автоматически предзаполнять поля?**](#js-question_195)

[**Как можно отправить форму без JavaScript?**](#js-question_197)

[**Можно ли после отправки формы отобразить ответ в новом окне или вкладке?**](#js-question_196)

[**Что такое BOM?**](#js-question_198)

[**Каким образом можно получить доступ к информации о браузере?**](#js-question_199)

[**Возможно ли получить доступ к URL и перенаправить пользователя на другую страницу? А к истории?**](#js-question_200)

<br>

# Вопросы по блоку JS (из списка вопросов подготовки после темы)

## Общие вопросы по блоку JS

<br>

### 1. <a name="js-question_1"></a> Какие методы HTTP-запросов вы знаете?

<br>

HTTP - это протокол передачи гипертекста. Связь между клиентами и серверами осуществляется посредством запросов и
ответов.

Метод `GET` запрашивает представление ресурса.

Запросы с использованием этого метода могут только извлекать
данные.

Метод `POST` используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или
какие-то побочные эффекты на сервере.

Метод `HEAD` запрашивает ресурс так же, как и метод GET, но без тела ответа.

Метод `PUT` создаёт новый ресурс или заменяет представление целевого ресурса, данными представленными в теле запроса.

`DELETE` удаляет указанный ресурс.

`CONNECT` устанавливает "туннель" (соединение) с сервером, определённого ресурса.

`OPTIONS` используется для описания параметров соединения с ресурсом.

`TRACE` выполняет вызов возвращаемого тестового сообщения с
ресурса.

`PATCH` используется для частичного изменения ресурса.
<br>
<br>

### 2. <a name="js-question_2"></a> Какие версии HTTP-протокола вам известны?

<br>
HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим
получателем, обычно веб-браузером (web-browser). Клиенты и серверы взаимодействуют, обмениваясь одиночными сообщениями (
а не потоком данных). Сообщения, отправленные клиентом, обычно веб-браузером, называются запросами, а сообщения,
отправленные сервером, называются ответами. HTTP является протоколом прикладного уровня, который чаще всего использует
возможности другого протокола - TCP (или TLS - защищённый TCP) - для пересылки своих сообщений. HTTP был предложен в
марте 1991 года Тимом Бернерсом-Ли.

`HTTP/1.0` в июне 1999 года. Новым в этой версии был режим «постоянного соединения»:
TCP-соединение может оставаться открытым после отправки ответа на запрос, что позволяет посылать несколько запросов за
одно соединение.

`HTTP/2` 11 февраля 2015 года опубликованы финальные версии протокола 2.
В отличие от предыдущих версий,
протокол `HTTP/2` является бинарным. Среди ключевых особенностей: мультиплексирование запросов, расстановка приоритетов
для запросов, сжатие заголовков, загрузка нескольких элементов параллельно посредством одного TCP-соединения, поддержка
проактивных push-уведомлений со стороны сервера.

`HTTP/3` – предлагаемый последователь HTTP/2. Основное отличие -
использование UDP вместо TCP в качестве транспортного протокола. UDP использует простую модель передачи, без неявных
«рукопожатий» для обеспечения надёжности, упорядочивания или целостности данных. Таким образом, UDP предоставляет
ненадёжный сервис.
Поддержка `HTTP/3` была добавлена в `Cloudflare и Google Chrome` в сентябре 2019 года и может быть
включена в стабильных версиях Chrome и Firefox.
<br><br>

### 3. <a name="js-question_3"></a> Какие знаете коды ответа (состояния) HTTP?

<br>
Коды сгруппированы в 5 классов:

1. Информационные `100 - 199`
2. Успешные `200 - 299`
3. Перенаправления `300 - 399`
4. Клиентские ошибки `400 - 499`
5. Серверные ошибки `500 - 599`

Код ответа об успешном статусе `The HTTP 200 OK` указывает, что запрос выполнен успешно.

Код состояния ответа `HTTP 400 Bad Request` указывает, что сервер не смог понять запрос из-за недействительного
синтаксиса. Клиент не должен повторять этот запрос без изменений.

Код ответа на статус ошибки `HTTP 401 Unauthorized`
клиента указывает, что запрос не был применён, поскольку ему не хватает действительных учётных данных для целевого
ресурса.

Код ответа на статус ошибки `HTTP 403 Forbidden` указывает, что сервер понял запрос, но отказывается его
авторизовать. Код ответа на ошибку `HTTP 404 Not Found` указывает, что сервер не может найти запрошенный ресурс.
Ссылки, ведущие к коду 404, часто называются сломанными или мёртвыми связями.

Код ответа сервера `500 Internal Server Error` указывает на то, что сервер столкнулся с неожиданной ошибкой. Обычно это означает, что сервер не смог найти
более подходящего кода ответа.
<br><br>

### 4. <a name="js-question_4"></a> Что такое Cross-Origin Resource Sharing? Как устранить проблемы с CORS?

<br>
(CORS) — «совместное использование ресурсов между разными источниками». Технология современных браузеров, которая
позволяет предоставить веб-страницам доступ к ресурсам другого домена.

Пример cross-origin запроса: HTML страница,
обслуживаемая сервером с

http://domain-a.com, запрашивает <img> src по адресу http://domain-b.com/image.jpg

Более подробно можно почитать (https://developer.mozilla.org/ru/docs/Web/HTTP/CORS)
<br><br>

### 5. <a name="js-question_5"></a> Что такое cookie?

<br>
HTTP cookie (web cookie, cookie браузера) - это небольшой фрагмент данных, отправляемый сервером на браузер
пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу. Это позволяет узнать, с
одного ли браузера пришли оба запроса (например, для аутентификации пользователя). Cookie так же, запоминают информацию
о состоянии для протокола HTTP, который сам по себе этого делать не умеет.
<br><br>
Cookie используются, главным образом, для:

-   Управления сеансом (логины, корзины для виртуальных покупок)
-   Персонализации (пользовательские предпочтения)
-   Мониторинга (отслеживания поведения пользователя)

До недавнего времени cookie принято было использовать в качестве хранилища информации на стороне пользователя. Это могло
иметь смысл в отсутствии вариантов, но теперь, когда в распоряжении браузеров появились различные API (программные
интерфейсы приложения) для хранения данных, это уже не так актуально. Из-за того, что cookie пересылаются с каждым
запросом, они могут слишком сильно снижать производительность (особенно в мобильных устройствах).

В качестве хранилищ
данных на стороне пользователя вместо них нужно использовать `Web storage API (localStorage and sessionStorage)` и
`IndexedDB`.
<br><br>

### 6. <a name="js-question_6"></a>Какой максимальный размер cookie?

<br>

Размер всех файлов cookie не должен превышать `4093` байта (`4 kb`). Это означает, что можно иметь 1 cookie размером
4093 байта или 2 cookie размером 2045 байтов и т.д.
<br><br>

### 7. <a name="js-question_7"></a>Что означает директива 'use strict'?

<br>

Директива `"use strict"` (строгий режим) появилась в стандарте `ECMAScript 5`. Она добавила новые возможности в язык и
изменила некоторые из существующих. Чтобы устаревший код работал, как и раньше, по умолчанию подобную директиву не
применяют. Но при работе с новыми функциями, методами, которые есть в современных стандартах, для избегания конфликтов
со старым кодом рекомендуется использовать данную директиву. Прописывается строкой в начале кода. После объявления весь
код работает в «современном» режиме. Строгий режим принёс ряд изменений в обычную семантику JavaScript.
<br><br>
Во-первых,
строгий режим заменяет исключениями некоторые ошибки, которые интерпретатор JavaScript ранее молча пропускал.
<br><br>
Во-вторых,
строгий режим исправляет ошибки, которые мешали движкам JavaScript выполнять оптимизацию - в некоторых случаях код в
строгом режиме может быть оптимизирован для более быстрого выполнения, чем код в обычном режиме.
<br><br>
В-третьих, строгий
режим запрещает использовать некоторые элементы синтаксиса, которые, вероятно, в следующих версиях ECMAScript получат
особый смысл. Строгий режим применяется ко всему скрипту или к отдельным функциям. Он не может быть применён к блокам
операторов, заключенных в фигурные скобки - попытка использовать его в подобном контексте будет проигнорирована.
<br><br>

### 8. <a name="js-question_8"></a>Что такое статическая и динамическая типизации?

<br>

В программировании `"типизация"` — это классификация информации. Чтобы понимать разницу между динамической и статической
типизацией, нам сначала нужно посмотреть, как написанные программы становятся запущенными программами. Код, который вы
пишете, обычно конвертируется в понятную для запуска компьютером форму.

Этот процесс называется компиляцией, а
промежуток времени, за который это происходит — "стадией компиляции" или `compile time`. После того, как компиляция
закончена и программа запущена, начинается отсчёт времени, который называется "стадией исполнения" или `run time`.
Некоторые языки проверяют типы и ищут ошибки типизации на стадии компиляции.
Это статическая типизация.

Другие языки
проверяют типы и ищут ошибки типизации на стадии исполнения. Такая типизация — динамическая. Статическая типизация
означает проверку типов перед запуском программы, динамическая — проверку типов, когда программа запущена. JavaScript
является слабо типизированным или язык с динамической типизацией. Это значит, что вам не нужно определять тип переменной
заранее. Тип определится автоматически во время исполнения программы. Также это значит, что вы можете использовать одну
переменную для хранения данных различных типов:
`let foo = 42;` // сейчас foo типа Number `foo = "bar";` // а теперь foo типа `String foo = true;` // foo становится типа `Boolean`

`typeof` — это специальный оператор, который возвращает строку, в которой написан тип.

<br>

### 9. <a name="js-question_9"></a>Как клиент взаимодействует с сервером?

<br>

Веб-браузеры `(клиенты)` взаимодействуют с веб-серверами при помощи протокола передачи гипертекста `(HTTP)` (запросов).
Когда вы кликаете на ссылку на странице, заполняете форму или производите поиск, браузер отправляет на сервер
HTTP-запрос. Этот запрос включает:

-   Путь `(URL)`, который определяет целевой сервер и ресурс (например, HTML-файл);
-   Метод `(GET, POST, HEAD, DELETE и т.д.)` который определяет необходимое действие (например, получить файл, сохранить,
    удалить);
-   Дополнительная информация. Может быть закодирована в запросе путем добавления пары ключ-значение (
    пример: http://mysite.com?name=Fred&age=11).

В этом случае всегда ставится знак вопроса `(?)`, отделяющий основную часть
URL-адреса от URL-параметров, знак равно `(=)`, отделяющий каждое имя от соответствующего ему значения, и амперсанд `(&)`,
разделяющий пары. URL-параметры, по своей сути, «небезопасны», так как могут быть изменены пользователями и затем
отправлены повторно. Так же в дополнительной информации могут быть переданы куки-файлы клиентской части, для
определения статуса пользователя его авторизации и разрешения/права доступа к ресурсам. Веб-серверы ожидают сообщений
с запросами от клиентов, обрабатывают их, когда они приходят и отвечают веб-браузеру через сообщение с HTTP-ответом.
Ответ содержит код статуса HTTP-ответа, который показывает, был ли запрос успешным (например, `«200 OK»` означает успех,
`«404 Not Found»`). После того как HTML-страница возвращена, она отрисовывается браузером. Также стоит заметить, что в
основе взаимодействия клиент-сервер лежит принцип того, что такое взаимодействие начинает клиент, сервер лишь отвечает
клиенту и сообщает о том может ли он предоставить услугу клиенту и если может, то на каких условиях. Данная концепция
взаимодействия была разработана в первую очередь для того, чтобы разделить нагрузку между участниками процесса обмена
информацией, а также для того, чтобы разделить программный код поставщика и заказчика. Мы видим, что к одному серверу
может обращаться сразу несколько клиентов. Количество клиентов, которые могут одновременно взаимодействовать с
сервером зависит от мощности сервера.
<br><br>

### 10. <a name="js-question_10"></a>Что такое REST?

<br>

`REST` - «передача состояния представления». Это архитектурный стиль взаимодействия компонентов распределенной системы в
компьютерной сети.

Проще говоря, REST определяет стиль взаимодействия (обмена данными) между разными компонентами
системы, каждая из которых может физически располагаться в разных местах.

REST определяет, как компоненты распределенной
системы должны взаимодействовать друг с другом. В общем случае это происходит посредством запросов-ответов. Компонент,
который отправляет запрос называют - клиентом; компонент, который обрабатывает запрос и отправляет клиенту ответ,
называют сервером.

Запросы и ответы, чаще всего, отправляются по протоколу HTTP. Приложение А может запрашивать данные у
приложения Б. Тогда `А` является клиентом по отношению к `Б`, а `Б` — сервером по отношению к `А`. Одновременно с этим, `А` может
обрабатывать запросы от В, Г, Д и т.д. В таком случае, приложение `А` является одновременно и сервером, и клиентом. Все
зависит от контекста.

Однозначно одно: компонента которая шлет запрос — это клиент. Компонента, которая принимает,
обрабатывает и отвечает на запрос — сервер. Однако не каждая система, чьи компоненты обмениваются данными посредством
запросов-ответов, является REST. Чтобы система считалась `RESTful`, она должна “вписываться” в шесть REST ограничений:

1. Приведение архитектуры к модели клиент-сервер;
2. Отсутствие состояния (в период между запросами серверу не нужно хранить информацию о состоянии клиента и наоборот);
3. Кэширование (клиенты могут выполнять кэширование ответов сервера);
4. Единообразие интерфейса (клиент должен всегда понимать в каком формате слать запрос на сервер, а сервер в каком
   формате ответить);
5. Слои (применение в пути запроса клиент-сервер дополнительных промежуточных серверов (слоев)). Пример: пользователь
   запрашивает картинку с сервера, а сервер перегружен, применение промежуточных серверов-слоев решит данную проблему,
   так как промежуточный сервер для загрузки какртинки пользователя выберет тот который в данный момент менее загружен;
6. Код по требованию (необязательное ограничение). Клиент может расширять свою функциональность, за счет загрузки кода с
   сервера в виде апплетов или сценариев. Приимущества REST: производительность, масштабируемость, простота интерфейсов,
   лёгкость внесения изменений. Подробно: https://javarush.ru/groups/posts/2486-obzor-rest-chastjh-1-chto-takoe-rest
   <br>
   <br>

### 11. <a name="js-question_11"></a>Объяснить понятие мутабельность/иммутабельность? Какие типы являются мутабельными и наоборот?

<br>
Мутабельность в JavaScript – это изменение объекта или массива без создания новой переменной и переприсваивания
значения.

Пример:

```JavaScript
const puppy = {name: 'Dessi', age: 9};
puppy.age = 10;
```

Подобные ошибки трудно заметить, ведь операции выполняются
нормально – только с результатом что-то не так. Решением являются `Иммутабельные (неизменяемые)` структуры данных. Эта
концепция предусматривает создание нового объекта для каждого обновления.

`Иммутабельным (англ. immutable)` называется
объект, состояние которого не может быть изменено после создания. Результатом любой модификации такого объекта всегда
будет новый объект (его копия), при этом старый объект не изменится. Речь не идет о глубоком копировании: если объект
имеет вложенную структуру, то все вложенные объекты, не подвергшиеся модификации, будут переиспользованы.

Методы для
иммутабельной работы с данными распатронены в React, пример:

```JavaScript
Array.map(),
Array.filter().
```

На практике существует два
типа мутаций (изменений) — видимые и невидимые. Видимые мутации — это мутации, изменяющие данные или структуру,
содержащую эти данные, способом, который контролируется внешним наблюдателем через API.

Невидимые мутации не могут
контролироваться через API (хорошим примером являются кэширующие структуры данных). В некотором смысле невидимые
изменения могут рассматриваться как сайд-эффекты `(side-effects)`. В контексте функционального программирования обычно
запрещены оба вида модификаций: не только данные являются иммутабельными по умолчанию, но и структуры данных не могут
быть изменены после создания.

Иммутабельные структуры данных в JS:

1. Тип переменной `const`, который уже создает препятствия для переопределения значения;
2. `string`, `number`, `boolean`, `symbol`, `null`, `undefined` и `bigint` (7 типов кроме объекта);

Мутабельный: `objject`.

`Object.freeze() / deepFreeze` - метод который делает данные внутри объекта не изменяемыми (замороженными).
<br><br>

### 12. <a name="js-question_12"></a>Как искать ошибки в коде? Используете ли вы дебаггер?

<br>
1. Отлавливать ошибки через консоль браузера.

Ошибка подсвечивается красным, читается слева направо. Как только ошибка
появляется - консоль нам ее отображает, нам сразу показывается информация о найденных ошибках. Сведения об ошибке
содержат следующие данные для ее поиска и устранения - строка где ошибка, тип ошибки, наименование файла с ошибкой.
Использование (breakpoints) в браузере. Вкладка Source. Точка останова – это участок кода, где отладчик автоматически
приостановит исполнение JavaScript. Так же доступна функция пошагового выполнения кода.

2. Внутри самого кода использую команду debugger для остановки, либо расставляя console.log(для вывода значений
   переменных)

3. Использование стронних web сервисов для анализа и визуализации кода. Копируем код в представленное окно, и система
   автоматически его проверит, но если в нем будет, хоть малейшая опечатка либо ошибка, получим такую ошибку с номером
   строки. Пример http://pythontutor.com/visualize.html#mode=edit
   В данных сервисах есть возможность пошагового выполнения кода, а так же наглядная визуализация значения переменных.
4. Использование встроенного дебагера редактора. Идея отладки заключается в возможности вызывать так называемые точки
   останова, чтобы приостановить выполнение кода. Это дает возможность посмотреть на состояние приложения, выполнив
   проверку переменных и т.п. Вы даже можете пойти дальше и отследить отдельные переменные, чтобы каждый раз, когда ваше
   приложение приостанавливается, вы могли проверить именно их значения.
   <br><br><br>

## JS Core:

<br>

### 1. <a name="js-question_13"></a>Какие существуют типы данных в JS?

<br>
Стандарт ECMAScript определяет 8 типов:

6 типов данных являющихся примитивами:

-   `Undefined` (Неопределённый тип),
-   `Boolean` (Булев, Логический тип),
-   `Number` (Число),
-   `String` (Строка),
-   `BigInt`, (большое число)
-   `Symbol` (в ECMAScript 6).

2 типа объектов:

-   `Null` (Null тип ) : typeof instance === "object".
    Специальный примитив, используемый не только для данных но и в
    качестве указателя на финальную точку в Цепочке Прототипов;

-   `Object` (Объект) : typeof instance === "object". Простая
    структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся
    с использованием ключевого слова new: new Object, new Array, new Map (en-US), new Set, new WeakMap, new WeakSet, new
    Date и множество других структур;
    <br><br>

### 2. <a name="js-question_14"></a>Как проверить, является ли объект массивом?

<br>

Метод `Array.isArray()` возвращает `true`, если объект является массивом и `false`, если он массивом не является. Возможен
вариант проверки с оператором `instanceof`. Он проверяет, принадлежит ли объект к определённому классу. Другими словами,
`object instanceof constructor` проверяет, присутствует ли объект constructor.prototype в цепочке прототипов `object`. Но
предпочтительнее проверять по `Array.isArray()`.
<br><br>

### 3. <a name="js-question_15"></a>Как проверить, что переменная равна NaN?

<br>

Возможна проверка через функцию `isNaN(значение)`. Функция определяет является ли литерал или переменная нечисловым
значением (NaN) или нет. При работе с функцией необходимо проявлять осторожность так как она имеет свои особенности. В
качестве альтернативы можно использовать метод `Number.isNaN()` из ECMAScript 6, или дополнительно проверять литерал или
переменную на нечисловое значение при помощи `typeof`.
<br><br>

### 4. <a name="js-question_16"></a>Сравните ключевые слова var, let, const.

<br>

ES2015 (ES6) появляются `let` и `const`. В JavaScript есть два типа области видимости — глобальная и локальная. Если
переменная создаётся внутри объявления функции, то её область видимости определяется как локальная и ограничивается этой
функцией.

-   `var` объявляет переменную, инициализируя ее при необходимости (может всплывать);
-   `let` объявляет переменную с блочной областью видимости и возможностью инициализации (переприсваиванию);
-   `const` задает константу, значение которой не может быть изменено новым присваиванием, а также не может быть
    переопределено, имеют блочную область видимости.

Сперва сравним `var` и `let`.

Главное отличие `let` в том, что область
видимости переменной ограничивается блоком, а не функцией. Другими словами, переменная, созданная с помощью оператора
`let`, доступна внутри блока, в котором она была создана и в любом вложенном блоке. Говоря «блок», я имею ввиду всё что
вложено между фигурными скобками `{}`, как например в цикле `for` или условии `if`.

Получается, что `const` и `let` почти одно и
тоже. И всё же есть одно отличие: значение переменной, объявленной с помощью `const`, нельзя переназначить.
<br><br>

### 5. <a name="js-question_17"></a>Что такое область видимости?

<br>

“Область видимости” (англ. `variable scope` или просто `scope`) — это область программы, в пределах которой
установлена связь между некоторой переменной и её идентификатором (именем), по которому можно получить значение этой
переменной. За пределами области видимости тот же самый идентификатор может быть связан с другой переменной, либо быть
свободным (вообще не связанным ни с какой из переменных).

Существует глобальная и локальная области видимости.

Область
видимости функции - функция, в котором она определена, или целая программа, если она объявлена по уровню выше.
<br><br>

### 6. <a name="js-question_18"></a>Что такое деструктуризация?

<br>

Деструктуризация (`destructuring assignment`, разбиение на части) – это особый синтаксис присваивания, при котором можно
присвоить массив или объект сразу нескольким переменным, разбив его на части. Пример деструктуризации массива:

```JavaScript
let [firstName, lastName] = ["Илья", "Иванов"];
```

<br>

### 7. <a name="js-question_19"></a>Для чего предназначены методы setTimeout и setInterval?

<br>

• setTimeout позволяет вызвать функцию (включенный код) один раз через определённый интервал времени. • setInterval
позволяет вызывать функцию (включенный код) регулярно, повторяя вызов через определённый интервал времени.
<br><br>

### 8. <a name="js-question_20"></a>Сравните подходы работы с асинхронным кодом: callbacks vs promises vs async / await.

<br>

`Асинхронные колбэки (callbacks)` (старый способ) — это функции, которые определяются как аргументы при вызове функции,
которая начнёт выполнение кода на заднем фоне. Когда код на заднем фоне завершает свою работу, он вызывает
колбэк-функцию, оповещающую, что работа сделана, либо оповещающую о трудностях в завершении работы.

```JavaScript
btn.addEventListener('click', () => { alert('You clicked me!'); });
```

Пример асинхронного колбэка вторым параметром `addEventListener()`
При передаче колбэк-функции как аргумента в другую функцию, мы передаём только ссылку на функцию как аргумент,
следовательно колбэк-функция не выполняется мгновенно. Она вызывается асинхронно внутри тела, содержащего функцию. Эта
функция должна выполнять колбэк-функцию в нужный момент (после получения данных).

Колбэк-функции универсальны — они не
только позволяют вам контролировать порядок, в котором запускаются функции и данные, передающиеся между ними, они также
позволяют передавать данные различным функциям, в зависимости от обстоятельств. Вы можете выполнять различные действия с
загруженным ответом, такие как `processJSON(), displayText()`, и другие.

`Промисы` — новый стиль написания асинхронного кода, который используется в современных `Web API`. Хорошим примером является
`fetch() API`. `fetch()` принимает один параметр — `URL` ресурса, который нужно получить из сети, — и возвращает промис.

Промис — это объект, представляющий асинхронную операцию, выполненную удачно или неудачно.

Он представляет собой как бы
промежуточное состояние. По сути, это способ браузера сказать: "я обещаю вернуться к вам с ответом как можно скорее",
поэтому в дословном переводе "промис" (`promise`) означает "обещание". Далее идут цепочки .then(). Каждый .then() блок
возвращает новый promise, это значит что вы можете объединять в цепочки блоки и таким образом можно выполнить несколько
асинхронных операций по порядку, одну за другой. Завершается catch(), этот блок описывается в конце и будет запущен если
какой-либо .then() блок завершится с ошибкой.

Приимущества промисов:

-   объединение несколько асинхронных операций вместе, используя несколько операций.then();
-   обработка ошибок намного
    лучше;
-   промисы избегают инверсии управления, в отличие от колбэков, которые теряют полный контроль над тем, как будет
    выполняться функция при передаче колбэка в стороннюю библиотеку.

В ECMAScript версии 2017 появились `async functions` и ключевое слово `await`. Такая функция делает две вещи:

-   Оборачивает возвращаемое значение в `Promise`
-   Позволяет использовать ключевое слово `await`.
    Мы можем использовать `await` перед `promise-based` функцией, чтобы остановить
    поток выполнения и дождаться результата её выполнения (результат Promise). В то же время, остальной код нашего
    приложения не блокируется и продолжает работать.
    Можно использовать `await` перед любой функцией, что возвращает
    `Promise`, включая `Browser API функции`.

    ```JavaScript
    async function hello() {
        return greeting = await Promise.resolve("Hello");
    };

    hello().then(alert);
    ```

    <br>

### 9. <a name="js-question_21"></a>Можно ли записывать новые свойства / функции в прототипы стандартных классов (Array, Object и т. д.)? Почему нет? В каких случаях это делать можно? Как обезопасить себя, если нужно расширить прототип?

<br>

У объектов в JS имеются собственные и унаследованные свойства.

```JavaScript
var foo = { bar: 1 }; где foo.bar === 1 // true -
собственное, а typeof foo.toString === "function" // true - унаследованное свойство.
```

У объекта есть ссылка на другой
объект-прототип. При доступе к полю `foo.toString` сначала выполняется поиск такого свойства у самого объекта, а потом у
его прототипа, прототипа его прототипа, и так пока цепочка прототипов не закончится. У всех прототипов имеются два общих
свойства, `constructor` и `proto`.

Свойство constructor указывает на функцию-конструктор, с помощью которой создавался
объект, а свойство `proto` указывает на следующий прототип в цепочке (либо null, если это последний прототип).

`constructor` – это ссылка на функцию, с помощью которой был создан объект. Для изменения прототипа у существующего
объекта есть всего два метода: использование сеттера `proto` и метод
Object.setPrototypeOf:

```JavaScript
var myProto = { name: "Jake" };
var foo = {};

Object.setPrototypeOf(foo, myProto);
foo.proto = myProto;
```

Встроенные прототипы можно
изменять. В том числе — добавлять свои методы. Допустимо изменение прототипа встроенных объектов, которое добавляет
поддержку метода из современных стандартов в те браузеры, где её пока нет. Например, добавим `Object.create(proto)` в
старые браузеры. Стандарстные прототипы изменять можно, но все же не рекомендуется во избежание конфликтов. Что бы
обезопасить себя или если браузер не поддерживает ни один из этих методов, то изменить прототип объекта невозможно,
можно только создать его копию с новым прототипом.
<br><br>

### 10. <a name="js-question_22"></a>Назовите методы массивов, какие помните, и скажите, для чего они нужны.

<br>

-   arr.push(...items)` – добавляет элементы в конец,
-   arr.pop() – извлекает элемент из конца, arr.shift() – извлекает элемент
    из начала,
-   arr.unshift(...items) – добавляет элементы в начало.
-   arr.splice(); - умеет всё: добавлять, удалять и заменять
    элементы.
-   arr.slice(start, end) - возвращает новый массив, в который копирует элементы, начиная с индекса start и до
    end (не включая end)
-   arr.concat(arg1, arg2...) - создаёт новый массив, в который копирует данные из других массивов и дополнительные
    значения.
-   arr.forEach позволяет запускать функцию для каждого элемента массива. - arr.indexOf(item, from) ищет item,
    начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
-   arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
-   arr.includes(item, from) – ищет item, начиная с
    индекса from, и возвращает true, если поиск успешен.
-   arr.find(function(item, index, array)) - поиск по условию
-   arr.filter() - ищет один (первый попавшийся) элемент, на котором функция-колбэк вернёт true. Возвращает массив из всех
    подходящих элементов arr.map - вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения
    этой функции.
-   arr.sort() сортирует массив на месте, меняя в нём порядок элементов arr.reverse меняет порядок элементов в
    arr на обратный
-   str.split(',') - создает массив из строки по заданному разделителю

Методы `arr.reduce` и `arr.reduceRight` -
используются для вычисления какого-нибудь единого значения на основе всего массива Пример:

```JavaScript
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
```

сумма элементов массива одной строкой

-   Array.isArray(
    value) - проверка является ли объект массивом
    <br><br>

### 11. <a name="js-question_23"></a>Какие методы перебора массива знаете? В чем их отличие?

<br>

-   arr.forEach позволяет запускать функцию для каждого элемента массива.
-   arr.filter() - ищет один (первый попавшийся)
    элемент, на котором функция-колбэк вернёт true. Возвращает массив из всех подходящих элементов
-   arr.map - вызывает
    функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

-   arr.reduce и
    arr.reduceRight - используются для вычисления какого-нибудь единого значения на основе всего массива
-   arr.every/some -
    используются для проверки массива, возвращают true, если вызов callback вернёт true для каждого элемента arr

```JavaScript
let arr = [1, -1, 2, -2, 3];

function isPositive(number) {
    return number > 0;
}
```

Во многих ситуациях их использование позволяет
написать код короче и понятнее, чем обычный перебор через `for, for … in` (для разреженных массивов).
<br><br>

### 12. <a name="js-question_24"></a>Как работают операторы присваивания / сравнения / строчные / арифметические / битовые и т. д.?

<br>

В JavaScript есть следующие типы операторов:

`Операторы присваивания.`

В результате операции присваивания операнду слева от оператора присваивания `(знак "=")`
устанавливается значение, которое берётся из правого операнда. Основным оператором присваивания является `=`, он
присваивает значение правого операнда операнду, находящемуся слева. Таким образом, выражение `x = y` означает, что `x`
присваивается значение `y`. Для более сложного присваивания в JavaScript есть синтаксис деструктуризации - это выражение,
которое позволяет извлекать данные из массивов или объектов, используя синтаксис, который зеркалирует конструкторы
массивов и литералы объектов.

`Операторы сравнения.`

Оператор сравнения сравнивает свои операнды и возвращает логическое
значение, базируясь на истинности сравнения. Операнды могут быть числами, строками, логическими величинами или
объектами. Строки сравниваются на основании стандартного лексикографического порядка, используя Unicode-значения. В
большинстве случаев, если операнды имеют разный тип, то JavaScript пробует преобразовать их в тип, подходящий для
сравнения. Такое поведение обычно происходит при сравнении числовых операндов. Единственным исключением из данного
правила является сравнение с использованием операторов `===` и `!==`, которые производят строгое сравнение на равенство или
неравенство. Эти операторы не пытаются преобразовать операнды перед их сравнением.

`Арифметические операторы.`

Арифметические операторы используют в качестве своих операндов числа (также литералы или переменные) и в качестве
результата возвращают одно числовое значение. Стандартными арифметическими операторами являются сложение `(+)`,
вычитание `(-)`, умножение `(\*)`, и деление `(/)`. Деление на ноль возвращает бесконечность `Infinity`.

`Битовые операторы.`

Обрабатывают свои операнды как последовательности из 32 бит (нулей и единиц), а не как десятичные, шестнадцатеричные или
восьмеричные числа. Например, десятичное число 9 имеет двоичное представление 1001. Битовые операторы выполняют операции
над таким двоичным представлением, но результат возвращают как обычное числовое значение JavaScript.

`Логические операторы.`

Логические операторы обычно используются с булевыми (логическими) значениями при этом возвращаемое ими
значение также является булевым. Однако операторы `&&` и `||` фактически возвращают значение одного из операндов, поэтому,
если эти операторы используются с небулевыми величинами, то возвращаемая ими величина также может быть не булевой.
Строковые операторы. В дополнение к операторам сравнения, которые могут использоватьс я со строковыми значениями,
оператор `(+)` позволяет объединить две строки, возвращая при этом третью строку, которая представляет собой объединение
двух строк-операндов.

`Условный (тернарный) оператор.`

Условный оператор является единственным оператором JavaScript,
который использует три операнда. Оператор принимает одно из двух значений в зависимости от заданного условия. Синтаксис
оператора: `condition ? val1 : val2`.

`Оператор запятая.`

Оператор запятая `,` просто вычисляет оба операнда и возвращает
значение последнего операнда. Данный оператор в основном используется внутри цикла `for`, что позволяет при каждом
прохождении цикла одновременно обновлять значения нескольких переменных.

`Унарные операторы.`

Унарная операция - операция
только с одним операндом. Оператор `delete` выполняет удаление объекта, свойства объекта, или элемента массива с заданным
индексом. Синтаксис оператора: `delete objectName`.

`Операторы отношения.`

Оператор отношения сравнивает свои операнды и
возвращает результат сравнения в виде булева значения `propNameOrNumber in objectName`. JavaScript поддерживает бинарные и
унарные операторы, а также ещё один специальный тернарный оператор - условный оператор.

Бинарная операция использует два
операнда, один перед оператором и другой за ним.
<br><br>

### 13. <a name="js-question_25"></a>Что означает глубокая (deep) и поверхностная (shallow) копия объекта? Как сделать каждую из них?

<br>

Язык JavaScript имеет примитивные

-   Number,
-   String,
-   Boolean,
-   Symbol и др)

и ссылочные

-   Array,
-   Object,
-   Function,
-   Maps,
-   Sets и др) типы данных.

Нужно отметить, что примитивные типы данных, являются `иммутабельными` — их значения не могут быть
модифицированы, а только `перезаписаны` новым полным значением, а вот с ссылочными типами данных все наоборот.

`Deep Copy` -
Глубокое копирование. Когда вы создаете глубокую копию, вы создаете идентичную копию исходного элемента с его
свойствами. Оригинал и копия не связаны, что означает, если вы изменили свойства оригинала, это не повлияет на
скопированный элемент и не изменит его.

`Shallow copy` - Поверхностное копирование. Rогда вы создаете поверхностную копию,
вы просто помещаете ссылку на оригинальный объект в другую переменную.Таким образом, когда вы меняете оригинал, это
также повлияет и изменит скопированный, и то же самое, если вы изменили что-то в скопированном элементе, это же что-то
изменится и в оригинале.

Примитивы: Примитивы, такие как числа, строки и логические значения, копируются "глубоко", что
означает, что скопированный элемент и оригинал не связаны.

Объекты:` Object.assign ()`, который создает совершенно новую и
отдельную копию. (Метод не выполняет глубокой копии вложенных объектов или массивов в оригинальный объект)

`JSON.parse() и JSON.stringify()` преобразует переданный элемент в строку с форматом JSON. Затем
`JSON.parse ()` преобразует его обратно в объект JavaScript, это позволяет выполнять глубокое клонирование и для вложенных
объектов.

Массивы: методы `map, filter, reduce` - создают новую копию.

`JSON.parse() и JSON.stringify()` - единственный
способ полного копирования.

Копия при помощи `Spread (…)` оператора не является глубокой вложенных объектов или массивов в
оригинальный объект
<br><br>

## Функции:

<br>

### 1. <a name="js-question_26"></a>Какая разница между декларацией функции (function declaration) и функциональным выражением (function expression)?

<br>

`Function Declaration` - классическре объявление функции.
Пример:

```JavaScript
function Foo(параметры) {
// Function Declaration
};
```

`Function Expression` -
альтернативный синтаксис для объявления функции, когда она присваивается другой переменной. Пример:

```JavaScript
let f = function(параметры) {
// Function Expression
};
```

Function Declaration – функция, объявленная в основном потоке кода.

Function Expression –
объявление функции в контексте какого-либо выражения, например присваивания.

Основное отличие между ними: функции,
объявленные как Function Declaration, создаются интерпретатором до выполнения кода. Поэтому их можно вызвать до
объявления. А Function Expression только после объявления.

Function Declaration при use strict видны только внутри
блока, в котором объявлены. Function Declaration можно использовать во всем скрипте (или блоке кода, если функция
объявлена в блоке).
<br>
<br>

### 2. <a name="js-question_27"></a>Что такое анонимная функция?

<br>

Функциональное выражение, которое не записывается в переменную, называют анонимной функцией. Если мы не собираемся
вызывать её ещё раз, можно просто объявить непосредственно там, где функция нужна. Пример:

```JavaScript
function () {
    alert("...");
};
```

<br>

### 3. <a name="js-question_28"></a>Расскажите о стрелочных функциях (arrow function). В чем заключаются отличия стрелочных функций от обычных?

<br>

Выражения стрелочных функций имеют более короткий синтаксис по сравнению с функциональными выражениями и лексически
привязаны к значению `this` снаружи (своего нет!).

Выражение стрелочных функций не позволяют задавать имя, поэтому
стрелочные функции анонимны, если их ни к чему не присвоить.

Пример:

```JavaScript
(() => { expression; });
```

Стрелочные функции не имеют
собственного объекта `arguments`, поэтому в теле стрелочных функций arguments будет ссылаться на переменную в окружающей
области.

```JavaScript
var arguments = 42;
var arr = () => arguments;
```

Функции-стрелки могут быть использованы так же, как и Function
Expression. Функции-стрелки очень удобны для однострочных действий. Они бывают двух типов:

Без фигурных скобок: `(...args) => expression` – правая сторона выражение: функция выполняет его и возвращает результат.

С
фигурными скобками: `(...args) => { body }` – скобки позволяют нам писать многострочные инструкции внутри функции, но при
этом необходимо указывать директиву return, чтобы вернуть какое-либо значение.

Итого:

-   Не имеют `this`.
-   Не имеют переменной `arguments`.
-   Не могут быть вызваны с `new`.
-   У них также нет `super`
    <br><br>

### 4. <a name="js-question_29"></a>Что такое и для чего используют IIFE (Immediately Invoked Function Expression) самовызывающаяся функция?

<br>

Это JavaScript функция, которая выполняется сразу же после того, как она была определена.

```JavaScript
(function () {statements})();
```

Это тип выражений, также известный как `Self-Executing Anonymous Function`, который состоит из двух основных частей.

Первая - это сама анонимная функция с лексической областью видимости, заключённым внутри Оператора группировки ().
Благодаря этому переменные IIFE замыкаются в его пределах, и глобальная область видимости ими не засоряется.

Вторая
часть создаёт мгновенно выполняющееся функциональное выражение `()` , благодаря которому JavaScript-движок выполняет
функцию напрямую.

Преимущество от использования само вызывающихся функций вы получите, если нужно выполнить код один раз
и сохранить его результаты во "внешней среде" (без объявления глобальных переменных).
Например, для небольшой
веб-страницы можно написать обработчики событий для элементов на странице. Само вызывающиеся функции подходящее средство
для такой ситуации.
<br><br>

### 5. <a name="js-question_30"></a>Что такое hoisting, как он работает для переменных и функций?

<br>

Поднятие или `hoisting` — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей
области видимости перед тем, как код будет выполнен. Как следствие, это означает то, что совершенно неважно где были
объявлены функция или переменные, все они передвигаются вверх своей области видимости, вне зависимости от того локальная
она или же глобальная.

Стоит отметить то, что механизм “поднятия” передвигает только объявления функции или переменной.
Назначения переменным остаются на своих местах. Запомните и держите в уме одну важную деталь, JavaScript непреклонно
сначала объявляет, а уже затем инициализирует наши переменные.

Подробно: https://medium.com/@stasonmars/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5%D0%BC-hoisting-%D0%B2-javascript-7d2d27bc51f1
<br><br>

### 6. <a name="js-question_31"></a>Что такое замыкание (closure) и какие сценарии его использования?

<br>

`Замыкание` — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами,
замыкание даёт вам доступ к `Scope` внешней функции из внутренней функции.

В JavaScript замыкания создаются каждый раз при
создании функции, во время её создания. Пример:

```JavaScript
function init() {
    let name = "Mozilla"; // name - локальная переменная, созданная в init
    function () { // - внутренняя функция, замыкание
    alert (name); // использует переменную, объявленную в родительской функции
    }();
}();
```

Замыкания
полезны тем, что позволяют связать данные `(лексическое окружение)` с функцией, которая работает с этими данными.

Очевидна
параллель с объектно-ориентированным программированием, где объекты позволяют нам связать некоторые данные (свойства
объекта) с одним или несколькими методами.

Следовательно, замыкания можно использовать везде, где вы обычно использовали
объект с одним единственным методом. Такие ситуации повсеместно встречаются в web-разработке. Большое количество
front-end кода, который мы пишем на JavaScript, основано на обработке событий. Мы описываем какое-то поведение, а потом
связываем его с событием, которое создаётся пользователем (например, клик мышкой или нажатие клавиши). При этом наш код
обычно привязывается к событию в виде обратного/ответного вызова `(callback)`: callback функция - функция выполняемая в
ответ на возникновение события.
<br><br>

### 7. <a name="js-question_32"></a>Что такое рекурсия?

<br>

`Рекурсия` – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько
аналогичных, но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той
же задачи. Или, как мы скоро увидим, для работы с определёнными структурами данных. В процессе выполнения задачи в теле
функции могут быть вызваны другие функции для выполнения подзадач. Частный случай подвызова – когда функция вызывает
сама себя. Это как раз и называется рекурсией.

Рекурсивное решение задачи обычно короче, чем итеративное. Используя
условный оператор `?` вместо `if`, мы можем переписать `pow(x, n)`, делая код функции более лаконичным, но всё ещё легко
читаемым:

```JavaScript
function pow(x, n) {
    return (n == 1) ? x : (x \* pow(x, n - 1));
}
```

Общее количество вложенных вызовов (включая первый)
называют глубиной рекурсии. В нашем случае она будет равна ровно `n`. Максимальная глубина рекурсии ограничена движком
JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для
большинства из них 100000 вызовов – за пределами возможностей.
<br><br>

### 8. <a name="js-question_33"></a>Что означает ключевое слово this?

<br>

`this` - cвойство контекста выполнения кода `(global, function или eval)`, которое в нестрогом режиме всегда является
ссылкой на объект, а в строгом режиме может иметь любое значение.

Как правило, методу объекта необходим доступ к
информации, которая хранится в объекте, чтобы выполнить с ней какие-либо действия (в соответствии с назначением метода).
Для доступа к информации внутри объекта метод может использовать ключевое слово this.

Значение this – это объект «перед
точкой», который использовался для вызова метода. Пример - если метод вызван в объект user его можно указать
`user.sayHi()`, а можно `this.sayHi()`. Значение `this` вычисляется во время выполнения кода и зависит от контекста. Например,
одна и та же функция назначена двум разным объектам и может иметь различное значение «this» при вызовах.
<br><br>

### 9. <a name="js-question_34"></a>Что такое потеря контекста, когда происходит и как ее предотвратить?

<br>

`Потеря контекста` – это прерывание связи функции вызова с данными основного объекта. При передаче методов объекта в
качестве колбэков, например, для `setTimeout`, возникает известная проблема – потеря this. Как только метод передаётся
отдельно от объекта – this теряется.
Пример:

```JavaScript
let user = { firstName: "Вася",
sayHi() {
    alert(`Привет, ${this.firstName}!`);
    }
};
setTimeout(user.sayHi, 1000); // Привет, undefined!
```

Это произошло потому, что `setTimeout` получил функцию `sayHi` отдельно от объекта `user` (именно здесь функция и потеряла
контекст).

Решение: 1. Самый простой вариант решения – это обернуть вызов в анонимную функцию, создав замыкание:

```JavaScript
setTimeout(() => user.sayHi(), 1000); // Привет, Вася!
```

Решение 2: привязать контекст с помощью `bind`.
Результатом вызова `func.bind(context)` является особый «экзотический
объект» (термин взят из спецификации), который вызывается как функция и прозрачно передаёт вызов в func, при этом
устанавливая `this=context`.

Подробно: https://learn.javascript.ru/bind
<br><br>

### 10. <a name="js-question_35"></a>Методы функций bind / call / apply - зачем и в чем разница?

<br>

В JavaScript функции это объекты, как вы должны были бы уже знать. И как объекты, функции имеют свои методы, включая
такие действенные, как `apply()`, `call()` и `bind()`.

Можно сказать, что `Apply()` и `Call()` буквально идентичны друг другу и
зачастую используются в JavaScript для того, чтобы заимствовать методы и выставлять значения this.

Также мы используем
`Apply()` для функций с большим количеством переменных и аргументов, но об этом вы узнаете дальше в статье.

В основном, мы
используем метод `bind()`, чтобы вызывать функцию с указанием значения this. А другими словами, `bind()` позволяет нам легко
выставлять какой именно объект будет привязан к `this` в момент вызова функции или метода. Метод `bind()` создаёт новую
функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также
передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её
вызове.

Привязанная функция также может быть сконструирована с помощью оператора `new`: это работает так, как если бы
вместо неё конструировалась целевая функция. Предоставляемое значение this в этом случае игнорируется, хотя ведущие
аргументы всё ещё передаются в эмулируемую функцию. `bind()` полезен там, где привязка контекста и вызов функции
происходят в разных местах и, как правило, в разное время.

Метод `apply()` вызывает функцию с указанным значением this и
аргументами, предоставленными в виде массива (либо массивоподобного объекта). С помощью apply() вы можете написать метод
один раз, а затем наследовать его в других объектах без необходимости переписывать метод для каждого нового объекта.
Метод apply очень похож на метод call(), за исключением поддерживаемого типа аргументов. Вы можете использовать массив
аргументов вместо набора именованных параметров.

Метод `call()` вызывает функцию с указанным значением this и
индивидуально предоставленными аргументами. Благодаря методу call() любой объект может использовать методы,
принадлежащие другому объекту.

Метод `call()` может принимать аргументы. Все аргументы метода call(), следующие за первым
аргументом, который определяет контекст вызова, передаются вызываемой функции. func.call( obj, 1, 2, 3 );

Разница:

-   `call()` - вызывает ту же функцию с указанными аргументами .
-   `apply()` - вызывает ту же функцию с аргументами, указанными в
    массиве
-   `bind()` - создает новую функцию с тем же телом функции с заданным значением `this` (первый аргумент) и возвращает
    эту функцию.

Во всех случаях первый аргумент используется в качестве значения this внутри функции.
<br><br>

## Front-end:

### 1. <a name="js-question_36"></a>Что такое DOM?

<br>

Объектная Модель Документа `(DOM)` является программным интерфейсом для `HTML`, `XML` и `SVG` документов. Это обеспечивает
структурированное представление документа (дерева), и определяет способ, по которому структура может быть доступна для
программы, для изменения структуры документа, его стиля и содержания.

`DOM` обеспечивает представление документа в виде
структурированной группы узлов и объектов, которые имеют свойства и методы. По сути, она связывает веб -страницы со
скриптами или языками программирования.
<br><br>

### 2. <a name="js-question_37"></a>Сравните атрибуты подключения скрипта async и defer в HTML-документе.

<br>

Когда браузер загружает HTML и доходит до тега `<script>...</script>`, он не может продолжать строить DOM. Он должен
сначала выполнить скрипт.

То же самое происходит и с внешними скриптами `<script src="..."></script>`: браузер должен
подождать, пока загрузится скрипт, выполнить его, и только затем обработать остальную страницу.

Это ведёт к двум важным
проблемам:

1. скрипты не видят DOM-элементы ниже себя,

2. Если вверху страницы объёмный скрипт, он «блокирует» страницу.
   Пользователи не видят содержимое страницы, пока он не загрузится и не запустится.

Атрибут `defer` сообщает браузеру, что
он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда он
загрузится. Содержимое после скрипта отображается сразу же.

```HTML
<script defer src="..."></script>.
```

Скрипты с `defer` никогда не блокируют страницу.

Скрипты с `defer` всегда выполняются, когда дерево `DOM` готово, но до
события `DOMContentLoaded`.

Атрибут `async` означает, что скрипт абсолютно независим. Страница не ждёт асинхронных скриптов,
содержимое обрабатывается и отображается. Событие `DOMContentLoaded` и асинхронные скрипты не ждут друг друга. Остальные
скрипты не ждут async, и скрипты casync не ждут другие скрипты. Так что, если у нас есть несколько скриптов с async, они
могут выполняться в любом порядке. То, что первое загрузится – запустится в первую очередь.
Пример

```HTML
<script async src="..."></script>
```

Мы можем также добавить скрипт и динамически, с помощью JavaScript. Динамически загружаемые скрипты по умолчанию ведут
себя как «async».
<br><br>

### 3. <a name="js-question_38"></a>Какая разница между свойствами HTML-элементов innerHTML и innerText?

<br>

Свойство интерфейса `element.innerHTML = htmlString` представляет собой содержимое элемента (элементы-потомки,
комментарии, текст и т.д.), которое хранится в нём в виде строки. Свойство доступно для чтения и записи, поэтому у нас
есть возможность получать и изменять содержимое элемента. Это свойство предоставляет простой способ полностью заменить
содержимое элемента.

`document.body.innerHTML = ""`, Заменяет содержимое тела пустой строкой. При установке нового
содержимого, сначала удаляется старое содержимое элемента, и только затем устанавливается новое.

`.innerText` - это
свойство, позволяющее задавать или получать текстовое содержимое элемента и его потомков.

В отличие от `innerText, innerHTML` позволяет работать с форматированным текстом HTML и не выполняет автоматическое кодирование и декодирование
текста. Другими словами, innerText извлекает и устанавливает содержимое тега в виде простого текста, тогда как innerHTML
извлекает и устанавливает содержимое в формате HTML.

`innerText` сокращает пробел между строками и добавляет разрывы строк
между элементами. innerText не будет возвращать текст для невидимых элементов.
<br><br>

### 4. <a name="js-question_39"></a>Опишите процесс всплытия (bubbling) событий в DOM.

<br>

`Всплытие`.

Принцип всплытия очень простой. Когда на элементе происходит событие, обработчики сначала срабатывают на нём,
потом на его родителе, затем выше и так далее, вверх по цепочке предков.

Например, есть 3 вложенных элемента FORM >
DIV > P с обработчиком на каждом.

Клик по внутреннему `<p>` вызовет обработчик onclick. Сначала на самом `<p>`, потом на
внешнем `<div>`, затем на внешнем `<form>`. И так далее вверх по цепочке до самого `document`.

Этот процесс называется
`«всплытием»`, потому что события `«всплывают»` от внутреннего элемента вверх через родителей подобно тому, как всплывает
пузырёк воздуха в воде. Почти все события всплывают.

Событие `focus` - не встплывает. Всегда можно узнать, на каком
конкретно элементе произошло событие.

Самый глубокий элемент, который вызывает событие, называется `целевым элементом`, и
он доступен через `event.target`.

Если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы.

### 5. <a name="js-question_40"></a>Как остановить всплытие (bubbling) события?

<br>

Всплытие идёт с `«целевого»` элемента прямо наверх. По умолчанию событие будет всплывать до элемента `<html>`, а затем до
объекта `document`, а иногда даже до `window`, вызывая все обработчики на своём пути.

Но любой промежуточный обработчик
может решить, что событие полностью обработано, и остановить всплытие. этого нужно вызвать метод `event.stopPropagation()`

Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.
То есть, `event.stopPropagation()` препятствует продвижению события дальше, но на текущем элементе все обработчики будут
вызваны.

Для того, чтобы полностью остановить обработку, существует метод
`event.stopImmediatePropagation()`. Он не только предотвращает всплытие, но и останавливает обработку событий
на текущем элементе.
<br><br>

### 6. <a name="js-question_41"></a>Как остановить дефолтную обработку события?

<br>

Любой обработчик может остановить событие вызовом `event.stopPropagation()`, но делать это не рекомендуется, так как в
дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.
<br><br>

### 7. <a name="js-question_42"></a>Чему равен this в обработчике событий (event handler)?

<br>

Внутри обработчика события `this` ссылается на текущий элемент, то есть на тот, на котором, как говорят, «висит» (т.е.
назначен) обработчик. В коде ниже button выводит своё содержимое, используя

```JavaScript
this.innerHTML <button onclick="alert(this.innerHTML)">Нажми меня</button>
```

<br>

### 8. <a name="js-question_43"></a>Что такое LocalStorage и SessionStorage? Какой максимальный размер LocalStorage?

<br>

Объекты веб-хранилища `localStorage` и `sessionStorage` позволяют хранить пары ключ/значение в браузере.

Данные, которые в
них записаны, сохраняются после обновления страницы (в случае sessionStorage) и даже после перезапуска браузера (при
использовании localStorage).

Отличия от куков:

-   Объекты веб-хранилища не отправляются на сервер при каждом запросе. Поэтому мы можем хранить гораздо больше данных.
    Большинство браузеров могут сохранить от 2 до 10 мегабайта данных (или больше) в среднем 5, и этот размер можно поменять
    в настройках.

-   Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё
    делается при помощи JavaScript. Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы
    или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.

Особенности
localStorage:

-   Этот объект один на все вкладки и окна в рамках источника (один и тот же домен/протокол/порт).
-   Данные не имеют срока
    давности, по которому истекают и удаляются.
-   Сохраняются после перезапуска браузера и даже ОС.

Доступ как к обычному
объекту:

-   `setItem(key, value)` – сохранить пару ключ/значение.
-   `getItem(key)` – получить данные по ключу key.
-   `removeItem(key)` – удалить данные с ключом key.
-   `clear()` – удалить всё.
-   `key(index)` – получить ключ на заданной
    позиции.
    `length` – количество элементов в хранилище. Особенности sessionStorage:

Одинаковые методы sessionStorage существует только в рамках текущей вкладки браузера. Другая вкладка с той же страницей
будет иметь другое хранилище. Но оно разделяется между ифреймами на той же вкладке (при условии, что они из одного и
того же источника). Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.
<br><br>

### 9. <a name="js-question_44"></a>Как получить высоту блока? Его положение относительно границ документа?

<br>

Метод `Element.getBoundingClientRect()` возвращает размер элемента и его позицию относительно `viewport` (точки просмотра
или ширины экрана в пикселях CSS в масштабе 100%).

Возвращаемое значение - это объект `TextRectangle`, содержащий целый
элемент со со следующими `read-only` (неизменяемыми) свойствами:

-   left (слева);
-   top (верх);
-   right (справа);
-   bottom (низ);
-   x, y (x, y по оси координат);
-   width (ширина);
-   height (высота)."
    <br><br>

### <a name="js-question_45"></a>10. Что такое webpack?

<br>

`Вебпак` — это сборщик модулей. Он анализирует модули приложения, создает граф зависимостей, затем собирает модули в
правильном порядке в один или более бандл (`bundle`), на который может ссылаться файл `«index.html»`.

Обычно, при создании
приложения на JavaScript, код разделяется на несколько частей (модулей). Затем в файле `«index.html»` необходимо указать
ссылку на каждый скрипт. Это не только утомительно, но и подвержено ошибкам. Вебпак решает эти задачи. Не нужно
беспокоиться о последовательном включении всех скриптов.

Основной задачей вебпака является анализ модулей, их
опциональное преобразование и интеллектуальное объединение в один или более бандл, поэтому вебпаку нужно знать три вещи:

-   Точка входа приложения;
-   Преобразования, которые необходимо выполнить;
-   Точка выхода;

`Точка входа` - Сколько бы модулей не
содержало приложение, всегда имеется единственная точка входа. Этот модуль включает в себя остальные. Обычно, таким
файлом является index.js. Если мы сообщим вебпаку путь до этого файла, он использует его для создания графа зависимостей
приложения. Для этого необходимо добавить свойство `entry` в настройки вебпака со значением пути к главному файлу.

`Преобразования` - После добавления точки входа, нужно сообщить вебпаку о преобразованиях, которые необходимо выполнить
перед генерацией бандла. Для этого используются лоадеры. По умолчанию при создании графика зависимостей на основе
операторов `import / require()` вебпак способен обрабатывать только JavaScript и JSON-файлы. Основной задачей лоадеров,
как следует из их названия, является предоставление вебпаку возможности работать с другими типами файлов.

`Точка выхода` -
Следующим шагом является указание директории для бандла. Для этого нужно добавить свойство output в настройки вебпака.
Он собирает бандл и помещает его по указанному вами пути.
<br><br>

# Основные и общие вопросы. Раздел 2 (из таблицы exel)

<br>

## 1. Системы контроля версий (SVN, Git)

<br>

### <a name="js-question_46"></a>Каким образом можно загрузить проект из Git репозитория?

<br>

```
git clone.
```

### <a name="js-question_47"></a>Как получить свежее состояние ветки?

<br>

```
git pull repo branch.
```

### <a name="js-question_48"></a>В какой ветке необходимо начинать работу над задачей?

<br>

```
dev
```

### <a name="js-question_49"></a>Как загрузить ветку на репозиторий?

<br>

```
git push repository branch.
```

<br>

## 2. Рекурсия

<br>

### <a name="js-question_50"></a>Что такое рекурсивная функция?

<br>
Это функция, которая вызывает сама себя.
<br>
<br>

### <a name="js-question_51"></a>Каким образом функция может вызывать сама себя?

<br>

-   по имени;
-   `arguments.callee;` // запрещена в strict mode
-   по переменной, которая ссылается на эту функцию.
    <br><br>

### <a name="js-question_52"></a>К чему может привести некорректно спроектированная рекурсивная функция?

<br>

К бесконечному циклу.
<br><br>

## 3. Замыкание

<br>

### <a name="js-question_53"></a>Что такое замыкание?

<br>

Это комбинация функции и лексического окружения, в котором эта функция была определена.

`Closures` это один из главных
особенностей JavaScript.

JavaScript разрешает вложенность функций и предоставляет вложенной функции полный доступ ко
всем переменным и функциям, объявленным внутри внешней функции (и другим переменным и функцим, к которым имеет доступ
эта внешняя функция). Однако, внешняя функция не имеет доступа к переменным и функциям, объявленным во внутренней
функции. Это обеспечивает своего рода инкапсуляцию для переменных внутри вложенной функции.

Также, поскольку вложенная
функция имеет доступ к `scope` внешней функции, переменные и функции, объявленные во внешней функции, будет продолжать
существовать и после её выполнения для вложенной функции, если на них и на неё сохранился доступ (имеется ввиду, что
переменные, объявленные во внешней функции, сохраняются, только если внутренняя функция обращается к ним).

`Closure`
создается, когда вложенная функция как-то стала доступной в неком scope вне внешней функции.
<br><br>

## 4. Командная строка

<br>

### <a name="js-question_54"></a>Существует ли разница в работе с командной строкой между различными операционными системами (Windows, Linux, MacOS)?

<br>

Да, про это не стоит забывать, предполагая что приложение должно иметь возможность запускаться на всех ранее упомянутых
операционных системах.
<br><br>

### <a name="js-question_55"></a>Что такое переменная окружения?

<br>

Переменные окружения или переменные среды `(environment variables)` - это глобальные значения, расположенные на уровне
операционной системы и доступные программам.
<br><br>

### <a name="js-question_56"></a>Каким образом можно установить переменную окружения?

<br>

```
- Windows: SET VARIABLE_NAME=VALUE;
- Linux: export VARIABLE_NAME=VALUE;
- MacOS: export VARIABLE_NAME=VALUE;
```

### <a name="js-question_57"></a>Возможно ли поместить переменные окружения в определенный файл, который будет загружен непосредственно во время запуска приложения?

<br>

Да, это `".env"`. Так же необходимо подключить библиотеку `"dotenv"`.
<br><br>

### <a name="js-question_58"></a>Возможно ли создать несколько таких файлов таким образом, чтобы необходимый выбирался автоматически в зависимости от того, под какое окружение происходи сборка или запуск приложения?

<br>

Да:

```
.env // загружается во всех случаях
.env.local // загружается во всех случаях, игнорируется git
.env.[mode] // загружается только в указанном окружении
.env.[mode].local // загружается только в указанном окружении, игнорируется git
```

<br>

## 5. Основы HTTP

<br>

### <a name="js-question_59"></a>Что такое HTTP?

<br>

HTTP - это протокол передачи гипертекста. Связь между клиентами и серверами осуществляется посредсвам запросов и
ответов:

1. Клиент отправляет HTTP запрос на определенный домен;
2. DNS перенаправляет запрос на соответствующий домену IP адрес;
3. Вебсервер получает запрос;
4. Вебсервер запускает приложение, обрабатывающее запрос (либо передает ему управление);
5. Вебсервер отправляет HTTP ответ клиенту;
6. Клиент получает ответ.

Более подробно: https://developer.mozilla.org/ru/docs/Web/HTTP/Overview"
<br>
<br>

### <a name="js-question_60"></a>Назови самые распространенные методы HTTP запроса?

<br>

```
-   GET;
-   POST;
-   PUT;
-   DELETE;
-   PATCH;
-   OPTIONS.
```

### <a name="js-question_61"></a>Назови самые распространенные статусы ответа?

<br>

```
-   200 - Ok;
-   400 - Bad request;
-   401 - Unatuhorized;
-   403 - Forbidden;
-   404 - Not found;
-   500 - Internal server error.
```

<br>

### <a name="js-question_62"></a>Что такое кроссдоменные запросы?

<br>

`Cross-Origin Resource Sharing (CORS)` - механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность
клиенту получать разрешения на доступ к выбранным ресурсам с сервера на домене, отличном от того, что сайт использует в
данный момент.
<br>
<br>

## 2. Основы JS

<br>

## 1. Типы данных

<br>

### <a name="js-question_63"></a>Какие типы данных существуют в JavaScript?

<br>

```
-   Number; => Infinity, NaN
-   String;
-   Boolean;
-   Object; => Function, AsyncFunction, Array
-   undefined;
-   null;
-   BigInt;
-   Symbol.
```

<br>

### <a name="js-question_64"></a>Корректно ли утверждение, что тип данных переменной может быть динамичен?

<br>

Да:

```
var x; // x is undefined
x = 5; // x is number
x = 'John'; // x is string
```

### <a name="js-question_65"></a>Какими способами можно представить число? (изменить формулировку)

<br>

-   10 - целоечиследнное представление;
-   1.01 - дробное представление;
-   12e-6 - экспоненциальное представление;
-   0b10 - бинарное представление;
-   0x1a - шестнадцатиричное представление.
    <br><br>

### <a name="js-question_66"></a>В чем разница между typeof и instanceof?

<br>

`Typeof` проверяет, относится ли переменная к одному из `7` типов данных: `number, string, boolean, object, function, undefined и Symbol.`

`Instanceof` проверяет, присутствует ли прототип правого операнда в цепочке прототипов левого
операнда.

Данный оператор не работает с примитивами.
<br><br>

### <a name="js-question_67"></a>В чем разница между числом (number) и Number?

Число (number) - примитив, Number - объект-обертка, позволяющая работать с числовыми значениями.

## 2. Способы объявления переменной и разница между ними

<br>

### <a name="js-question_68"></a>Каким образом можно определить переменную?

<br>

```JavaScript
-   var name1;
-   const name2;
-   let name3;
-   name4 = value; // Крайне не допустимый способ, в strict mode спровоцирует ReferenceError."
```

### <a name="js-question_69"></a>Какая разница между var, let и const?

<br>

-   `var` объявляет переменную, инициализируя ее при необходимости (может всплывать);
-   `let` объявляет переменную с блочной областью видимости и возможностью инициализации;
-   `const` задает константу, значение которой не может быть изменено новым присваиванием, а так же не может быть
    переопределено, имеют блочную область видимости."
    <br><br>

## 3. Преобразование типов

<br>

### <a name="js-question_70"></a>Какие числа при приведении к boolean будут обработаны как true, а какие как false?

<br>

Любое число, отличное от нуля приводится к `true`. Ноль - к `false`.
<br><br>

### <a name="js-question_71"></a>Объясни принцип работы следующей конструкции:

<br>

```
if (!!variable) { /_ ... _/ }
```

Двойное отрицание работает как преобразование к `boolean`. Стоит помнить, что это не всегда
применимо, так как, например, любой объект - это всегда `true`.
<br><br>

### <a name="js-question_72"></a>Что произойдет при сложении строки с числом?

<br>

Число будет преобразовано к строке и произойдет конкатенация двух строк:

```JavaScript
'Hello' + 1; // 'Hello1'

1 + 'Hello'; // '1Hello'
```

<br>

### <a name="js-question_73"></a>Что произойдет при разности строки и числа?

<br>

Строка будет преобразована к числу, причем если это невозможно, результатом операции будет NaN:

```JavaScript
'12' - 1; // 11

1 - '12'; // -11

'Hello' - 1; // NaN

1 - 'Hello'; // NaN
```

### <a name="js-question_74"></a>Каким оператором можно произвести преобразование к числу?

<br>

Унарный + или -:

```
-'11'; // 11 +'12'; // 12 -'Hello'; // NaN
```

При операции сложения или разности с объектами будет вызван метод `valueOf`.
<br><br>

## 4. Сравнения

<br>

### <a name="js-question_75"></a>В чем разница между "==" и "==="?

<br>

Двойное `"равно"` сравнивает с `приведением` типов, а тройное `без`. Причем, при строгом сравнении, если типы данных
отличаются, результатом такой операции будет `false`.
<br><br>

### <a name="js-question_76"></a>Как можно сравнить объекты?

<br>

Ни одним из приведенных способов (если необходимо сравнить их по значению), так как объекты сравниваются по `ссылке`, а не
`по значению`.

Выйти из ситуации можно реализовав собственную функцию для `глубокого сравнения` объекта по всем значениям
или подключить `библиотеку`, в которой эта функциональность уже реализована (`lodash, underscore`, и другие).
<br><br>

## 5. Условные и логические операторы

<br>

### <a name="js-question_77"></a>Что такое условный (тернарный) оператор?

<br>

Условный оператор является единственным оператором JavaScript, который использует три операнда. Оператор принимает одно
из двух значений в зависимости от заданного условия. Синтаксис оператора:

```JavaScript
condition ? val1 : val2
```

Если `condition (условие)` - истина, то оператор принимает значение `val1`. В противном случае оператор принимает значение
`val2`.
<br><br>

### <a name="js-question_78"></a>Назови основные логические операторы?

<br>

```
-  && - Логическое "И";
-  || - Логическое "ИЛИ";
-  ! - Логическое отрицание.
```

Логические выражения вычисляются слева направо, они проверяются на возможность выполнения
сокращённой оценки с использованием следующих правил:

-   `false && anything` - вернет `false`, не вычислив значение `anything`, так как в этом уже нет необходимости;
-   `true || anything` - вернет true по тем же причинам.
    <br>
    <br>

## 6. Функции и способы их определения, функциональные выражения

<br>

### <a name="js-question_79"></a>Как узнать, можно ли вызвать переменную `fn` как функцию?

<br>

```JavaScript
-   typeof fn === 'function';

-   instanceof fn;

-   fn.constructor.name === 'Function' // требует дополнительной проверки на наличие конструктора.
```

<br>

### <a name="js-question_80"></a>Произойдет ли ошибка в процессе работы данного скрипта?

<br>

```
foo(); function foo() { /_ ... _/ }
```

Нет, `foo` - это `function declaration`, которое объявляется в `"parse-time"`. Если бы функция была определена как `function expression`, то это действительно вызвало ошибку, так как она определяется в `run-time`.
<br><br>

### <a name="js-question_81"></a>Какая разница между функцией, методом и конструктором?

<br>

Метод - это функция, которая принадлежит объекту или классу. Конструктор возвращает новый объект `(this)` используя
оператор `new`.
<br><br>

### <a name="js-question_82"></a>Что такое IIFE (immediately invoked function expression)?

<br>

Это анонимная самовызывающаяся функция, котораязапускается сразу же после определения. Также, функция работает в
изолированной области видимости, что позволяет использовать такой подход для реализации паттерна `Модуль`.
<br><br>

### <a name="js-question_83"></a>Каким образом можно получить список всех аргументов функции из ее тела?

<br>

```
-   arguments (deprecated);
-   ...rest.
```

### <a name="js-question_84"></a>Можно ли подменить контекст выполнения функции?

<br>

Да, это делается одним из трех способов:

```JavaScript
-   Function.prototype.call // мгновенный вызов, аргументы через запятую;
-   Function.prototype.apply // мгновенный вызов, аргументы массивом;
-   Function.prototype.bind // создается функция-обертка для отложенного вызова, аргументы через запятую.
```

### <a name="js-question_85"></a>Что будет выведено в результате работы следующего кода:

<br>

```JavaScript
console.log(hello);
var hello = 'Hello!';
```

`Undefined`, так как переменная определенная через `var` всплывает:

```JavaScript
var hello = undefined;
console.log(hello);
hello = 'Hello!';
```

<br>

### <a name="js-question_86"></a>Что будет выведено в результате работы следующего кода:

<br>

```JavaScript
var employeeId = '1234abe';

(function(){ console.log(employeeId);
var employeeId = '122345';
})();
```

`Undefined`, так как `IIFE имеет свой контекст`, в
котором приоритет переходит на `локальную` переменную (так как их имена одинаковы), всплытие которой и произойдет.
<br>
<br>

## 2.7. Область видимости (Scope)

<br>

### <a name="js-question_87"></a>Что такое область видимости?

<br>

Область видимости функции - функция, в котором она определена, или целая программа, если она объявлена по уровню выше
<br><br>

### <a name="js-question_88"></a>Что произойдет в результате работы следующего кода:

<br>

```JavaScript
var foo = function bar() { return 1; };

console.log(typeof bar());
```

Произойдет ошибка `"ReferenceError"`, так как `bar` - это
функциональное выражение. `"bar"` ссылается на анонимную функцию, которая к моменту вызова `"console.log"` уже не доступна.
<br><br>

### <a name="js-question_89"></a>Что будет выведено в результате работы следующего кода:

<br>

```JavaScript
var A = 'hi there';

var B = A;

B = 'bye there!';

console.log(A);
```

`"hi there"`, так как строки передаются
по значению, а не по ссылке.
<br>
<br>

### <a name="js-question_90"></a>Что будет выведено в результате работы следующего кода:

<br>

```JavaScript
var objA = { prop1: 42 };

var objB = objA;

objB.prop1 = 90;

console.log(objA);
```

`{prop1: 90}`, так как объекты
передаются по ссылке, а не по значению.
<br>
<br>

### <a name="js-question_91"></a>Что будет выведено в результате работы следующего кода:

<br>

```
console.log(hello);
```

`ReferenceError`, так как `hello` не определена.

<br>

### <a name="js-question_92"></a>Может ли функция быть объявлена внутри другой функции?

<br>

Да, эту функцию можно будет вызвать из блока, в котором она была объявлена.

<br>

## 2.8. Обработка ошибок

<br>

### <a name="js-question_93"></a>Каким образом можно обработать ошибку?

<br>

```JavaScript
try { /_ ... _/ }

catch (error) { /_ ... _/ }

finally { /* ... */ }
```

### <a name="js-question_94"></a>Каким образом можно выбросить исключение?

<br>

Инструкция `throw` выбрасывает исключение
<br>
<br>

### <a name="js-question_95"></a>Какого типа исключения можно выбрасывать?

<br>

Любого:

```JavaScript
throw 'Error2';

throw 42;

throw true;

throw { toString: function() { return "I'm an object!"; } };

throw new Error('Error');
```

### <a name="js-question_96"></a>Обязательно ли использовать блок catch?

<br>

Нет, если есть блок `finally`.

При отсутствии `finally` использование `catch` обязательно:
catch (catchID) { statements } JavaScript создает идентификатор catchID, которому присваивается перехваченное
исключение, при входе в блок catch; данный идентификатор доступен только в пределах блока catch и уничтожается при
выходе из него."
<br><br>

### <a name="js-question_97"></a>Обязательно ли использовать блок finally?

<br>

Нет, не обязательно:
Блок `finally` содержит код, который будет выполнен после окончания работы блоков `try` и `catch`, но до того, как будет
выполнен код, который следует за инструкцией `try...catch`.

Блок `finally` выполняется вне зависимости от того, было ли
выброшено исключение.

Блок `finally` выполняется даже в том случае, если исключение не перехватывается в блоке `catch`.
<br>
<br>

### <a name="js-question_98"></a>Возможно ли создавать вложенные try...catch?

<br>

Да, можно вкладывать инструкции try...catch друг в друга. Если внутренняя инструкция try...catch не имеет блока catch,
то она должна иметь блок finally, кроме того исключение будет перехвачено во внешнем блоке catch.
<br><br>

## 2.9. Строгий режим (Strict mode)

<br>

### <a name="js-question_99"></a>Что такое строгий режим?

<br>

Режим `strict` (строгий режим), введенный в `ECMAScript 5`, позволяет использовать более строгий вариант JavaScript. Строгий
и обычный режим могут сосуществовать одновременно, а скрипт может переключаться в строгий режим по мере надобности.
<br><br>

### <a name="js-question_100"></a>К чему может быть применен строгий режим?

<br>

Строгий режим применяется ко всему скрипту или к отдельным функциям.

Он не может быть применён к блокам операторов,
заключенных в фигурные скобки - попытка использовать его в подобном контексте будет проигнорирована.
<br><br>

### <a name="js-question_101"></a>Как активировать строгий режим?

<br>

Чтобы активизировать строгий режим для всего скрипта, нужно поместить оператор `"use strict";` перед
всеми остальными операторами скрипта или функции.
<br><br>

### <a name="js-question_102"></a>Какие ограничения вводит строгий режим?

<br>

-   Невозможность случайного создания глобальных переменных:

    `someVariable = 10; // ReferenseError`

-   Невозможность присваивания значения глобальной переменной, защищенной от записи:

    `var undefined = 1; // TypeError var Infinity = 2; // TypeError`

-   Невозможность удаления неудаляемых свойств:

    `delete Object.prototype`

-   Свойства объекта должны быть уникальными:

    `var o = { p: 1, p: 2 }; // SyntaxError`

-   Имена аргументов функции должны быть уникальными:

    `function something(a, a, b) { /_ ... _/ } // SyntaxError`

-   Запрещает синтаксис восьмеричной системы счисления. Восьмеричный синтаксис не является частью ECMAScript, но
    поддерживается во всех браузерах с помощью дописывания нуля спереди к восьмеричному числу: 0644 === 420 и '\045' === '
    %'.

    В ECMAScript 2015 восьмеричное число поддерживается также с помощью дописывания перед числом '0o':
    var a = 0o10;

-   Запрещает установку свойств у примитивов:
    ```
    false.true = ''; // TypeError
    (10).something = ''; // TypeError
    'some'.thing = ''; // TypeError
    ```
-   Запрещает "with":
    `with (something) { /_ ... _/ } // SyntaxError`
-   `Eval` не добавляет новых переменных в окружающий контекст
-   Запрещает удаление переменных:
    `var x = 0; delete x; // SyntaxError`

-   `Eval и arguments` не могут быть переопределены
    `
-   Поля объекта `arguments` не связаны с проименованными аргументами функции, а являются их продублированными копиями
    значений
-   Свойство `arguments.callee` больше не поддерживается
-   Значение, передаваемое в функцию как `this`, в строгом режиме не приводится к объекту
-   Запрет на использование зарезервированных слов:

        `implements, interface, let, package, private, protected, public, static и yield` (есть особенности, связанные с
        браузерами)"

    <br><br>

## 2.10. Массивы и методы массивов

<br>

### <a name="js-question_103"></a>Как создать массив?

<br>

```JavaScript
const a1 = [];

const a2 = new Array();
```

### <a name="js-question_104"></a>Как отличить массив от объекта?

<br>

```JavaScript
-   Array.isArray; // проверка является ли объект массивом

-   array instanceof Array;

-   array.constructor.name === 'Array'; // (требует дополнительной проверки на наличие конструктора);

-   Object.prototype.toString.call(array) === '[object Array]';
```

### <a name="js-question_105"></a>Изменится ли длина массива, если задать новое значение для array.length?

<br>

Да, длина массива станер равной то, что будет задана в length. При уменьшении length массив будет обрезан, а при
увеличении в него добавятся новые элементы (empty или undefined в зависимости от браузера).
<br><br>

### <a name="js-question_106"></a>Какими способами можно создать массив из n элементов?

<br>

```JavaScript
-   const arr = new Array(n);

-   Array.apply(null, {length: n});

-   Array.from({ length: n }).
```

### <a name="js-question_107"></a>Каким способом можно создать новый массив на основании существующего так, чтобы он не содержал повторяющиеся значения?

<br>

```JavaScript
new Set(array).
```

### <a name="js-question_108"></a>Каким образом можно поэлементно обойти массив?

<br>

```JavaScript
- for(let i = 0; i < n; i += 1) { /_ ... _/ }; // по индексу

-  for(item in array) { /_ ... _/ }; // по элементам

-  array.forEach(function(element, index) { /_ ... _/ }); // по элементам и индексу
```

### <a name="js-question_109"></a>Каким образом можно объединить 2 и более массива?

<br>

```JavaScript
Array.prototype.concat.
```

<br>

### <a name="js-question_110"></a>Возможно ли объединить элементы массива в текстовую строку?

<br>

```JavaScript
Да, при помощи Array.prototype.join.
```

<br>

### <a name="js-question_111"></a>Как добавить элемент в конец массива?

<br>

```JavaScript
Array.prototype.push.
```

### <a name="js-question_112"></a>Как отсортировать массив?

<br>

```JavaScript
Array.prototype.sort.
```

Причем, данная функция принимает аргумент - функцию компаратор, которая может использоваться,
если необходимо применить другую логику к сортировке.
<br><br>

### <a name="js-question_113"></a>Как найти элемент в массиве?

<br>

-   Array.prototype.indexOf( ) - вернет индекс элемента;
-   Array.prototype.find( ) - вернет элемент массива;
-   Array.prototype.some( ) - вернет логическое значение наличия элемента в массиве.
    <br><br>

### <a name="js-question_114"></a>Может ли элемент массива быть массивом?

<br>

Да. Если каждый элемент массива является массивом, то такие массивы называют дву (много) мерными.
<br><br>

### <a name="js-question_115"></a>Является ли arguments массивом?

<br>

Нет, это `псевдомассив` или `массивоподобный объект`.

При помощи `Array.from` можно преобразовать его к массиву.
<br>
<br>

### <a name="js-question_116"></a>Какие словари существуют в JavaScript?

<br>

-   `Map` - это реализация простого ассоциативного массива. Он содержит данные в виде набора пар ключ/значение (ключи
    уникальны) и предоставляет методы для доступа и манипулирования этими данными;
-   `WeakMap` - это специальный вид словаря, ключами которого могут быть только объекты, причём ссылки на них в `WeakMap`
    являются слабыми (не учитываются сборщиком мусора (garbage collector GC)).
    <br><br>

### <a name="js-question_117"></a>Какие коллекции существуют в JavaScript?

<br>

-   `Set` - это реализация коллекции - структура данных, которая содержит список уникальных элементов в порядке их
    добавления.
-   `WeakSet` это специальный вид коллекции, элементами которой могут быть только объекты.

Ссылки на эти объекты в WeakSet
являютя слабыми (не учитываются сборщиком мусора (garbage collector GC)).
<br><br>

## 2.11. Объекты и методы объектов

<br>

### <a name="js-question_118"></a>Какие имена свойств могут быть у объектов?

<br>

Имена свойств объекта могут быть `строками JavaScript`, или тем, что `может быть сконвертировано в строку`, включая `пустую строку`. Как бы то ни было, доступ к любому имени свойства, которое содержит невалидный JavaScript идентификатор (
например, имя свойства содержит в себе пробел и тире или начинается с цифры), может быть получен с использованием
квадратных скобок. Этот способ записи также полезен, когда имена свойств должны быть динамически определены (когда имя
свойства не определено до момента исполнения):

```JavaScript
object.name = 'name';

object['string with space'];

object[dynamicVariable];

object[3];

object[' '];
```

### <a name="js-question_119"></a>Каким образом можно перечислить свойства объекта?

<br>

```
-   for...in;
-   Object.keys;
-   Object.getOwnPropertyNames.
```

<br>

### <a name="js-question_120"></a>Как узнать, существует ли у объекта определенное свойство или метод?

<br>

```JavaScript
-   name in object;

-   {}.hasOwnProperty.call(object, name); // не сработает, если свойство или метод находятся в прототипе.
```

<br>

### <a name="js-question_121"></a>Какими способами можно создать объект?

<br>

```JavaScript
const o1 = {};
const o2 = new Object();
const o3 = new CustomConstructor();
const o4 = Object.create();
```

### <a name="js-question_122"></a>Каким образом можно запретить модификацию объекта?

<br>

-   `Object.preventExtensions`, запрещает расширение объекта, но не запрещает удалять из него свойства или менять их
    значения;
-   `Object.seal`, работает подобным образом, но также запрещает удалять свойства;
-   `Object.`, предотвращает любые попытки модификации объекта.

<br><br>

### <a name="js-question_123"></a>Каким образом можно совместить два (и более) объекта в один

<br>

```
Object.assign;
Spread...;
```

### <a name="js-question_123-1"></a>Каким образом отработает следующий код:

<br>

```JavaScript
var x = 1; delete x;

console.log(x);
```

Оператор delete `используется для удаления свойств из объекта`, его действие не распространяется на переменные и свойства и методы прототипа. В результате работы в консоль браузера выведется число "1"
<br><br>

### <a name="js-question_124"></a>Корректно ли использовать такой код для удаления элементов массива, и если нет то почему:

<br>

```JavaScript
var list = ['red', 'green', 'blue'];

delete list[1];

console.log(list);

console.log(list.length);
```

Элемент не будет
удален из массива, его значением станет `undefined` или `empty` (в зависимости от браузера): ['red', empty, 'blue'].
Длина так же останется равной 3.
<br><br>

## 2.12. Конструктор, оператор "new"

<br>

### <a name="js-question_125"></a>Как создать объект при помощи функции-конструктора?

<br>

`var o = new SomeObject();`
<br><br>

### <a name="js-question_126"></a>Обязательно ли использовать круглые скобки при вызове конструктора?

<br>

Нет, если нет аргументов вызова.

Следующие конструкции будут работать одинаково:

`var o = new SomeObject; var o = new SomeObject();`
<br><br>

### <a name="js-question_127"></a>Что вернет пустая функция, вызванная с оператором new?

<br>

Пустой объект.

### <a name="js-question_128"></a>Что происходит при интерпретации "new Foo()"?

<br>

-   Создается новый объект, наследующий `Foo.prototype`;
-   Вызывается конструктор - функция `Foo` с указанными аргументами и `this`, привязанным к только что созданному объекту.
    `new Foo` эквивалентно `new Foo()`, то есть если аргументы не указаны, Foo вызывается без аргументов.
-   Результатом выражения new становится объект, возвращенный конструктором. Если конструктор не возвращет объект явно,
    используется объект из п. 1.
    <br><br>

## 2.13. Прототип: наследование, методы

<br>

### <a name="js-question_129"></a>Как называется объект, от которого произошло наследование?

<br>

Прототип.
<br><br>

### <a name="js-question_130"></a>Корректно ли выражение, что все объекты в конечном итоге унаследованы от какого-то одного? Если да, то от какого?

<br>

Да, от `Object.prototype`.
<br><br>

### <a name="js-question_131"></a>Каким образом ищется свойство в объекте при попытке доступа к нему?

<br>

При попытке получить доступ к какому-либо свойству объекта, свойство вначале ищется в самом объекте, затем в прототипе
объекта, после чего в прототипе прототипа, и так далее. Поиск ведется до тех пор, пока не найдено свойство с совпадающим
именем или не достигнут конец цепочки прототипов.
<br><br>

### <a name="js-question_132"></a>Что произойдет при вызове `o.m()`?

<br>

    var o = { a: 2, m: function() {
        return this.a + 1;
        }
    };
    o.m();

Будет выведено "3", так как при вызове "o.m" this указывает на "o".
<br><br>

### <a name="js-question_133"></a>Что произойдет при вызове p.m()?

<br>

    var o = { a: 2, m: function() { return this.a + 1; } };
    var p = Object.create(o);
    p.a = 12;
    p.m();

Будет выведено `13`. При вызове `p.m` this указывает на `p`. `p` наследует функцию `m` объекта `o`,
`this.a` означает `p.a`, собственное свойство `a` объекта `p`.
<br><br>

### <a name="js-question_134"></a>Создайте класс Person, реализующий прототипный метод "sayHello" и экземпляр этого класса средствами ES5

<br>

    var Person = function() {} Person.prototype.sayHello = function() {} var person = new Person();

### <a name="js-question_135"></a>Создайте класс Person, реализующий прототипный метод "sayHello" и экземпляр этого класса средствами ES6

<br>

    class Person { sayHello() {} } const person = new Person();

### <a name="js-question_aa"></a>Какими способами реализуется наследование?

<br>

```JavaScript
-   Object.create:

    Circle.prototype = Object.create(Shape.prototype); Circle.prototype.constructor = Circle;

-   Call:

    function Employee(fName, lName, eId) {
        Person.call(this, fName, lName);
        this.empId = eId;
    }

-   Extends:
    class Circle extends Shape {}
```

## 2.14. Классы, синтаксис, три столпа ООП

<br>

### <a name="js-question_136"></a>Каким образом можно определить класс?

<br>

```JavaScript
-   Class Declaration:

    class Polygon {}

-   Class Expression:

    var Polygon = class {}

-   Named Class Expression:

    var Polygon = class Polygon {}
```

### <a name="js-question_137"></a>Распространяется ли всплытие (hosting) на классы?

<br>

Да, так же как и на примере с функциями.
<br><br>

### <a name="js-question_138"></a>Можно ли принудительно включить строгий режим для тела класса?

<br>
Тела объявлений классов и выражений классов выполняются в строгом режиме
<br><br>

### <a name="js-question_139"></a>Что такое constructor?

<br>

специальный метод, необходимый для создания и инициализации объектов, созданных, с помощью класса. В классе может быть
только один метод с именем constructor. Исключение, типа SyntaxError, будет выброшено, если класс содержит более одного
вхождения метода constructor. Ключевое слово super можно использовать в методе constructor для вызова конструктора
родительского класса.
<br><br>

### <a name="js-question_140"></a>Как определить статический метод?

<br>

Ключевое слово `static`, определяет статический метод для класса. Статические методы вызываются без инстанцирования их
класса, и не могут быть вызваны у экземпляров `(instance)` класса. Статические методы, часто используются для создания
служебных функций для приложения.
<br><br>

### <a name="js-question_141"></a>Как обратиться к родительскому классу средствами ES6?

<br>

    super.

### <a name="js-question_142"></a>Что такое ООП?

<br>

Объектно-ориентированное программирование (ООП) - это парадигма программирования, которая использует абстракции, чтобы
создавать модели, основанные на объектах реального мира. ООП использует несколько техник из ранее признанных парадигм,
включая наследование, полиморфизм и инкапсуляция.
<br><br>

### <a name="js-question_143"></a>Что означает наследование?

<br>

Класс может наследовать характеристики от другого класса. Наследование - это способ создать класс как специализированную
версию одного или нескольких классов (JavaScript поддерживает только одиночное наследование). Специализированный класс,
как правило, называют потомком, а другой класс родителем. В JavaScript наследование осуществляется присвоением
экземпляра класса родителя классу потомку.
<br><br>

### <a name="js-question_bb"></a>Что означает инкапсуляция?

<br>

Способ комплектации данных и методов, которые используют данные. Сокрытие информации распространённая особенность, часто
реализуемая в других языках программирования как приватные и защищённые методы/свойства.
<br><br>

### <a name="js-question_144"></a>Что означает полиморфизм?

<br>

Поли означает "много", а морфизм "формы". Различные классы могут объявить один и тот же метод или свойство. Так как
все методы и свойства определяются внутри `prototype`, различные классы могут определять методы с одинаковыми именами.
Методы находятся в области видимости класса в котором они определены, пока два класса не имеют связи родитель-потомок (
например, один наследуется от другого в цепочке наследований).
<br><br>

## 2.15. Работа с ассинхронным кодом: функции обратного вызова, обещания (Promises), ассинхронные функции. Концепция "Callback Hell", промисификация, цикл событий

<br>

### <a name="js-question_145"></a>Что такое Promise?

<br>

Это объект, который используется для работы с отложенными и ассинхронными вычислениями.

### <a name="js-question_146"></a>Какие состояния есть у Promise?

<br>

1. Ожидание `(pending)`;
2. Выполнено `(fullfiled)`;
3. Отклонено `(rejected)`. Так же есть еще одно состояние: `settled`. Оно описывает, что обещание либо выполнено, либо
   отклонено, причем обещание не находится в состоянии ожидания.
   <br><br>

### <a name="js-question_147"></a>Каким образом можно создать Promise?

<br>

    new Promise(function executor(resolve, reject) { /_ ... _/ });

### <a name="js-question_148"></a>Каким образом можно выполнить несколько обещаний таким образом, чтобы дождаться выполнения всех или отклонения хотя бы одного?

<br>

```JavaScript
Promise .all([p1, p2])

.then(() => { /_ ... _/ })

.catch((e) => { /_ ... _/);
```

### <a name="js-question_149"></a>Что будет являться результатом выполнения Promise.all?

<br>

Массовое значений от всех обещаний, которые ему были преданы. Возвращаемый массив сохранит порядок оригинального
перечисляемого объекта.
<br><br>

### <a name="js-question_150"></a>Верно ли утверждение, что Promise.all будет завершать обещания одно за одним, по цепочке?

<br>

Нет, Promise.all не сохраняет порядок выполнения обещаний.
<br><br>

### <a name="js-question_151"></a>Каким образом можно дождаться выполнения только одного обещания из списка, которое произойдет быстрее всего?

<br>

    Promise.race([p1, p2])

    .all([p1, p2])

    .then(() => { /_ ... _/ })

    .catch((e) => { /_ ... _/);

### <a name="js-question_152"></a>Каким образом можно получить отклоненное обещание из произвольной переменной?

<br>

    Promise.reject(variable);

### <a name="js-question_153"></a>Каким образом можно получить успешно завершенное обещание из произвольной переменной?

    Promise.resolve(variable);

### <a name="js-question_154"></a>Возможно ли выполнить вызов непосредственно после завершения промиса в не зависимости от того, ушел ли он в ошибку или был resolved?

<br>

    Да, Promise.prototype.finally.

### <a name="js-question_155"></a>Что такое функция обратного вызова (callback)?

<br>

Это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо
действия.
<br>

### <a name="js-question_156"></a>Что такое callback hell?

<br>

Это антишаблон проектирования, который возникает при увеличении вложенности функций обратного вызова.
<br><br>

### <a name="js-question_157"></a>Как бороться с callback hell?

<br>

-   Вместо использования большой вложенности, можно разнести код по функциям или модулям.

    Это улучшит читаемость, stack
    trace будет ссылаться на фактические имена функций, а не на анонимные и это позволит перемещать функции и ссылаться на
    них по именам;

-   Промисы, генераторы и асинхронные функции.
    <br><br>

### <a name="js-question_158"></a>Что такое промисификация?

<br>

Это процесс оборачивания асинхронного кода таким образом, чтобы возвращался промис.
<br><br>

### <a name="js-question_159"></a>Что такое цикл событий (event loop)?

<br>

Это механизм для управления очередностью исполнения кода. Цикл событий регулирует последовательность исполнения
контекстов. Каждый раз, когда срабатывает событие, функция, которая должна быть выполнена при его появлении, помещается
в очередь исполнения, в `event loop`, который последовательно, с каждым циклом выполняет попадающий в него код. При этом
привязанная к событию функция вызывается следующей после текущего контекста исполнения.

```
-   Begin Loop;
-   setTimeout/setInterval;
-   События I/O;
-   setImmediate;
-   End Loop.
```

## 2.16. Концепция генераторов

<br>

### <a name="js-question_160"></a>Что такое генератор?

<br>

Это объект, возвращаемый функцией-генератором и соответствующий как `"Итерируемому"` протоколу, так и протоколу
`Итератор`. Генераторы являются функциями с возможностью выхода и последующего входа. Их контекст исполнения (значения
переменных) сохраняется при последующих входах.

Когда вызывается функция-генератор, её тело исполняется не сразу; вместо этого возвращается объект-итератор. При вызове
метода `next()` итератора тело функции-генератора исполняется до первого встреченного оператора `yield`, который определяет
возвращаемое значение или делегирует дальнейшее выполнение другому генератору при помощи `yield anotherGenerator()`.
Метод `next()` возвращает объект со свойством `value`, содержащим отданное значение, и свойством done, которое указывает,
что генератор уже отдал своё последнее значение. Вызов метода `next()` с аргументом прекращает выполнение
функции-генератора, и заменяет инструкцию `yield` на которой было приостановлено выполнение на аргумент переданный в
`next()`.
<br><br>

### <a name="js-question_161"></a>Как определить функцию-генератор?

<br>

function\* (ключевое слово function со звёздочкой) определяет функцию-генератор.

<br><br>

### <a name="js-question_162"></a>Можно ли инстанцировать (вызвать как функцию-конструктор) генератор?

<br>

Нет, генераторы не могут быть инстанцированы (`not constructable`):

```JavaScript
function\* f() {} var obj = new f; // throws ""TypeError: f is not a constructor""
```

### <a name="js-question_163"></a>Что такое протокол "Итератор"?

<br>

Протокол `Итератор` определяет стандартный способ получения последовательности значений (конечной или бесконечной).
Объект является итератором, если в нем определен метод `next()`, реализующий следующую логику: Функция без аргументов,
возвращающая объект с двумя свойствами:

-   done (boolean);
-   value.
    <br><br>

## 2.17. Модули, import/export

<br>

### <a name="js-question_164"></a>Что такое модуль?

<br>

Модулем считается файл с кодом. В этом файле ключевым словом export помечаются переменные и функции, которые могут быть
использованы снаружи. Другие модули могут подключать их через вызов `import`.
<br><br>

### <a name="js-question_165"></a>Что такое import?

<br>

Инструкция `import` используется для импорта ссылок на значения, экспортированные из внешнего модуля. На данный момент эта
функциональность только начинает поддерживаться браузерами. Полноценная реализация присутствует во многих транспайлерах,
таких как `TypeScript` и `Babel`, а также в сборщиках, например, в `Rollup` и `Webpack`.
<br><br>

### <a name="js-question_166"></a>Какими способами можно выполнить импорт?

<br>

-   Импорт значения по умолчанию:
    import defaultExport from ""module-name"";
-   Импорт всего модуля:
    import \* as name from ""module-name"";
-   Импорт единичного или нескольких единичных значений из модуля:
    import { export1 , export2 } from ""module-name"";
-   Импорт значений с использованием других имен:
    import { export as alias } from ""module-name"";
    <br><br>

### <a name="js-question_167"></a>Что такое export?

<br>

Инструкция export используется для экспорта функций, объектов или примитивов из файла (или модуля). Эта функциональность
не реализована в браузерах на данный момент, но она реализована во многих транспилерах, таких как `Traceur Compiler, Babel or Rollup`.
<br><br>

### <a name="js-question_168"></a>Какие типы экспорта существуют?

<br>

-   Именованный экспорт:
    `export { myFunction };

    `export const foo = Math.sqrt(2);`

-   Экспорт по умолчанию (один на скрипт):

        `export default function() {}`

    <br><br>

### <a name="js-question_169"></a>Какими способами можно произвести экспорт?

<br>

-   Использование именованного экспорта:
    `export { cube, foo };`
-   Использование экспорта по умолчанию:
    `export default function () { /_ ... _/ };`
-   Множественный экспорт:
    `export _ from './file1.js'; export _ from './file2.js';`
    <br><br>

## 2.18. Сетевые запросы: fetch/XHR

<br>

### <a name="js-question_170"></a>Каким образом можно выполнить сетевой запрос?

<br>

-   XMLHttpRequest;
-   fetch.

### <a name="js-question_171"></a>Что такое XMLHttpRequest?

<br>

Это API, который предоставляет клиенту функциональность для обмена данными между клиентом и сервером. Данный API
предоставляет простой способ получения данных по ссылке без перезагрузки страницы. Это позволяет обновлять только часть
веб-страницы не прерывая пользователя.
<br><br>

### <a name="js-question_172"></a>Каким образом можно отправить XMLHttpRequest?

<br>

Для отправки HTTP-запроса нужно создать XMLHttpRequest-объект, открыть URL и отправить запрос. После выполнения запроса
можно получить и обработать тело и статус ответа.

```JavaScript
function requestListener () { console.log(this.responseText); }

var req = new XMLHttpRequest();

req.onload = requestListener;

req.open(""get"", ""yourFile.txt"", true);

req.send();
```

### <a name="js-question_173"></a>Что такое FormData?

<br>

Это объект, который позволяет легко конструировать наборы пар `"ключ-значение"`, представляющие поля формы и их
значения, которые в дальнейшем можно отправить с помощью метода `send()`. FormData использует такой же формат на выходе,
как если бы мы отправляли обыкновенную форму с encoding установленным в `multipart/form-data`.
<br><br>

### <a name="js-question_174"></a>Что такое Fetch API?

<br>

`Fetch API` предоставляет интерфейс для получения ресурсов (в том числе по сети). Он покажется знакомым любому, кто
использовал `XMLHttpRequest`, но новый API является более мощным и гибким набором функций.
<br><br>

### <a name="js-question_175"></a>Каким образом можно создать запрос при помощи Fetch API?

<br>

```JavaScript
fetch('flowers.jpg')

.then(function(response) { return response.blob(); })

.then(function(myBlob) { var objectURL =
URL.createObjectURL(myBlob);

myImage.src = objectURL; });
```

### <a name="js-question_cc"></a>Каким образом при использовании Fetch API можно выполнить запрос с CORS?

<br>

Добавить `"mode: 'cors'"` в конфигурацию запроса.
<br><br>

## 3. Браузер: DOM, BOM, события

<br>

## 3.1. Дерево DOM

<br>

### <a name="js-question_176"></a>Что такое DOM?

<br>

Объектная Модель Документа `(DOM)` является программным интерфейсом для `HTML, XML и SVG` документов. Это обеспечивает
структурированное представление документа (дерева), и определяет способ, по которому структура может быть доступна для
программы, для изменения структуры документа, его стиля и содержания.

DOM обеспечивает представление документа в виде
структурированной группы узлов и объектов, которые имеют свойства и методы. По сути, она связывает веб -страницы со
скриптами или языками программирования.
<br><br>

### <a name="js-question_177"></a>Как можно обратиться к DOM?

<br>

    document (window.document).

<br>

### <a name="js-question_178"></a>Можно ли изменить стили DOM элемента?

<br>

Да, используя `element.style`.

### <a name="js-question_179"></a>Можно ли получить доступ ко всем стилям, примененным к документу?

<br>

Да, используя `document.styleSheets`.
<br><br>

## 3.2. Поиск по DOM

<br>

### <a name="js-question_180"></a>Какими способом можно найти элемент DOM?

<br>

-   document.getElementById;
-   document.getElementsByClassName;
-   document.getElementsByName;
-   document.getElementsByTagName;
-   document.querySelector;
-   document.querySelectorAll;"
    <br><br>

## 3.3. Атрибуты и свойства элемента

<br>

### <a name="js-question_181"></a>Что такое элемент?

<br>

Интерфейс Element представляет собой один из объектов в `Document`. Этот интерфейс описывает методы и свойства, общие для
всех видов элементов. Конкретные модели поведения описаны в интерфейсах, которые наследуют от Element, и добавляют
дополнительную функциональность.
<br><br>

### <a name="js-question_182"></a>Что такое атрибуты элемента?

<br>

Свойство `Element.attributes` возвращает группу атрибутов всех узлов, зарегистрированных в указанном узле. Это
`NamedNodeMap`, тоесть полученные данные не являются массивом `Array`, не содержат `Array` методы и `Attr` индекс узлов может
отличаться в различных браузерах. Если сказать более точно, атрибуты `(attributes)` это строка, пара ключ/значение которая
представляет собой информацию относительно этого атрибута.
<br><br>

### <a name="js-question_183"></a>Как получить доступ к атрибутам элемента?

<br>

    element.attributes.

Подробный список свойств и методов элемента: https://developer.mozilla.org/ru/docs/Web/API/Element
<br><br>

## 3.4. Размеры и скроллинг, координаты

<br>

### <a name="js-question_184"></a>Каким образом можно узнать ширину элемента?

<br>

    element.clientWidth

<br>

### <a name="js-question_185"></a>Можно ли изменив значение "element.clientWidth" изменить ширину элемента?

<br>

Нет, это свойство доступное только для чтения.
<br><br>

### <a name="js-question_186"></a>Каким образом можно узнать размер элемента?

<br>

Метод `Element.getBoundingClientRect()` возвращает размер элемента и его позицию относительно `viewport` (точки просмотра
или ширины экрана в пикселях CSS в масштабе 100%).

Данный метод возвращает объект `TextRectangle`, который является
объединением прямоугольников, возвращаемых методом `getClientRects()` для данного элемента, т. е. CSS border-boxes (
css-коробок в рамках), связанных с этим элементом. Возвращаемое значение - это объект `TextRectangle`, содержащий целый
элемент со со следующими read-only (неизменяемыми) свойствами:

-   left (слева);
-   top (верх);
-   right (справа);
-   bottom (низ);
-   x, y (x, y по оси координат);
-   width (ширина);
-   height (высота)."
    <br><br>

### <a name="js-question_187"></a>Возможно ли программно произвести скроллинг?

<br>

Можно:

-   `element.scrollIntoView()` прокручивает текущий элемент в видимую область окна браузера;
-   `element.scrollLeft()` получает или устанавливает количество пикселей, на которое контент элемента прокручен влево;
-   `element.scrollTop()` считывает или устанавливает количество пикселей, прокрученных от верха элемента;
-   `element.scroll()` прокручивает текущий элемент к переданным координатам;
-   `window.scrollTo()` прокручивает страницу до указанного места."
    <br><br>

## 3.5. События браузера: всплытие, перехват, действия по умолчанию

<br>

### <a name="js-question_jj"></a>Что такое событие (Event)?

<br>

Интерфейс `Event` представляет собой любое событие, которое происходит в DOM. Некоторые из них генерируемые
пользователем (клик мышью или нажатие клавиши на клавиатуре), а некоторые - генерируемые API (события, обозначающие
завершение процесса анимации, приостановка видео и т.д.).

Существует много типов событий, некоторые из них используют
интерфейсы, базирующиеся на главном интерфейсе Event. Event содержит общие свойства и методы для всех событий.
<br><br>

### <a name="js-question_188"></a>Каким образом можно создать событие?

<br>

    var evt = new Event("look", {"bubbles":true, "cancelable":false});

<br>

### <a name="js-question_189"></a>Каким образом можно инициировать ("запустить") событие?

<br>

    document.dispatchEvent(evt)

Событие может быть инициировано на любом элементе, не только на документе.
<br><br>

### <a name="js-question_190"></a>Каким образом можно создать обработчик события?

<br>

```JavaScript
const password = document.querySelector('input[type=""password""]');

password.addEventListener('focus', (event) => {
  event.target.style.background = 'pink';
});

password.addEventListener('blur', (event) => {
  event.target.style.background = '';
});

```

<br>

### <a name="js-question_191"></a>Возможно ли назначить сразу несколько обработчиков событий на один и тот же элемент?

<br>

Да, `Element.addEventListener` будет каждый раз добавлять новый обработчик события.
<br><br>

### <a name="js-question_192"></a>Возможно ли удалить обработчик события?

<br>

Да, используя `Element.removeEventListener`.
<br><br>

## 3.6. Формы: свойства и события формы, отправка без JS

<br>

### <a name="js-question_193"></a>Что такое элемент формы?

<br>

Элемент `HTML form (<form>)` представляет собой раздел документа, содержащий интерактивные элементы управления, которые позволяют пользователю отправлять информацию на веб-сервер.
<br><br>

### <a name="js-question_194"></a>Какое значение enctype должно быть установлено, если форма содержит input с типом "Файл"?

<br>

    multipart/form-data.

<br>

### <a name="js-question_195"></a>Можно ли разрешить форме автоматически предзаполнять поля?

<br>

Да, это делается при помощи атрибута `"autocomplete"`.
<br><br>

### <a name="js-question_196"></a>Можно ли после отправки формы отобразить ответ в новом окне или вкладке?

<br>

Да, имя или ключевое слово, показывающее где отображать ответ, который будет получен, после отправки формы. В HTML 4, это имя или ключевое слово для фрейма.

В HTML5, это имя или ключевое слово, контекста просмотра (например, вкладка, окно, или линейный фрейм). Следующие ключевые слова имееют специальное значение:

-   `_self`: Загружает ответ в том же самом фрейме HTML 4 (или HTML5 контексте просмотра) как текущий. Это значение по умолчанию, если атрибут не указан;
-   `_blank`: Загружает ответ в новом безымянном окне HTML 4 или HTML5 контексте просмотра;
-   `_parent`: Загружает ответ HTML 4 в родительском наборе фрейма для текущего фрейма или HTML5 родительский контекст просмотра для текущего просмотра. Если нет предка, эта опция действует точно так же как as \_self;
-   `_top`: HTML 4: Загружает ответ в полное, оригинальное окно, закрывая все другие фреймы.

HTML5: Загружает ответ в верхний уровень контекста просмотра (т.е., контекст просмотра это предок текущего и не имеет других предков). Если нет предка, эта опция действует точно так же как `as _self`.
<br><br>

### <a name="js-question_197"></a>Как можно отправить форму без JavaScript?

<br>

Форма должна иметь `button` с типом `"submit" (или элемент "submit")`. Адрес отправки задается в атрибуте `"action"`, а метод в атрибуте `"method"`.

<br><br>

## 3.7. BOM: объекты BOM, концепция

<br>

### <a name="js-question_198"></a>Что такое BOM?

<br>

BOM - это Browser Object Model, позволяет взаимодействовать с браузером.
<br><br>

### <a name="js-question_199"></a>Каким образом можно получить доступ к информации о браузере?

<br>

    - window.navigator.userAgent;
    - window.navigator.platform.

<br>

### <a name="js-question_200"></a>Возможно ли получить доступ к URL и перенаправить пользователя на другую страницу? А к истории?

<br>

Да, `window.location`.

Да, `window.history`.